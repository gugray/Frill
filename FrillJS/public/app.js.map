{"version":3,"sources":["node_modules/browser-pack/_prelude.js","node_modules/reconnectingwebsocket/reconnecting-websocket.js","app.js","src/js/data-client.js","src/js/main.js","src/js/utils.js"],"names":["e","t","n","r","s","o","u","a","require","i","f","Error","code","l","exports","call","length","1","module","global","factory","define","amd","ReconnectingWebSocket","this","url","protocols","options","generateEvent","args","evt","document","createEvent","initCustomEvent","settings","debug","automaticOpen","reconnectInterval","maxReconnectInterval","reconnectDecay","timeoutInterval","maxReconnectAttempts","key","reconnectAttempts","readyState","WebSocket","CONNECTING","protocol","ws","self","forcedClose","timedOut","eventTarget","createElement","addEventListener","event","onopen","onclose","onconnecting","onmessage","onerror","bind","removeEventListener","dispatchEvent","open","reconnectAttempt","debugAll","console","localWs","timeout","setTimeout","close","clearTimeout","OPEN","isReconnect","CLOSED","reason","wasClean","Math","pow","data","send","refresh","window","prototype","CLOSING","2","codeName","initSocketHandlers","DataClient","socket","connected","sendMyDetails","CustomEvent","detail","sender","message","msgObj","JSON","parse","msg","source","forceSendDetails","reportNewPeers","me","id","peers","receivedPeer","find","p","name","log","sourceId","peerList","forEach","push","color","onMsgPeers","peer","range","onMsgSelection","version","content","onMsgContent","delta","onMsgDelta","connect","wsAddr","location","host","disconnect","stringify","selectionChanged","contentChanged","oldDelta","index","reconnectingwebsocket","3","updateCursors","cm","dc","activePeers","updateAll","Object","keys","cursors","setCursor","removeCursor","colors","utils","dc1","dc2","q1","q2","cm1","cm2","quillParams","theme","placeholder","modules","autoRegisterListener","history","userOnly","readOnly","$","ready","Quill","register","QuillCursors","removeClass","updateColor","elmTxt","elmBtn","x","ix","abs","hash","val","addClass","elmTxtL","elmBtnL","on","elmTxtR","elmBtnR","wireupColors","clients","elm","elmButton","click","hasClass","prop","enable","attr","disable","html","esc","wireupConnectEvents","getModule","registerTextChangeListener","oldRange","q","setContents","updateContents","4","debounce","func","wait","immediate","context","arguments","callNow","apply","str","len","charCodeAt","replace"],"mappings":"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","file":"app.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","// MIT License:\n//\n// Copyright (c) 2010-2012, Joe Walnes\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n/**\n * This behaves like a WebSocket in every way, except if it fails to connect,\n * or it gets disconnected, it will repeatedly poll until it successfully connects\n * again.\n *\n * It is API compatible, so when you have:\n *   ws = new WebSocket('ws://....');\n * you can replace with:\n *   ws = new ReconnectingWebSocket('ws://....');\n *\n * The event stream will typically look like:\n *  onconnecting\n *  onopen\n *  onmessage\n *  onmessage\n *  onclose // lost connection\n *  onconnecting\n *  onopen  // sometime later...\n *  onmessage\n *  onmessage\n *  etc...\n *\n * It is API compatible with the standard WebSocket API, apart from the following members:\n *\n * - `bufferedAmount`\n * - `extensions`\n * - `binaryType`\n *\n * Latest version: https://github.com/joewalnes/reconnecting-websocket/\n * - Joe Walnes\n *\n * Syntax\n * ======\n * var socket = new ReconnectingWebSocket(url, protocols, options);\n *\n * Parameters\n * ==========\n * url - The url you are connecting to.\n * protocols - Optional string or array of protocols.\n * options - See below\n *\n * Options\n * =======\n * Options can either be passed upon instantiation or set after instantiation:\n *\n * var socket = new ReconnectingWebSocket(url, null, { debug: true, reconnectInterval: 4000 });\n *\n * or\n *\n * var socket = new ReconnectingWebSocket(url);\n * socket.debug = true;\n * socket.reconnectInterval = 4000;\n *\n * debug\n * - Whether this instance should log debug messages. Accepts true or false. Default: false.\n *\n * automaticOpen\n * - Whether or not the websocket should attempt to connect immediately upon instantiation. The socket can be manually opened or closed at any time using ws.open() and ws.close().\n *\n * reconnectInterval\n * - The number of milliseconds to delay before attempting to reconnect. Accepts integer. Default: 1000.\n *\n * maxReconnectInterval\n * - The maximum number of milliseconds to delay a reconnection attempt. Accepts integer. Default: 30000.\n *\n * reconnectDecay\n * - The rate of increase of the reconnect delay. Allows reconnect attempts to back off when problems persist. Accepts integer or float. Default: 1.5.\n *\n * timeoutInterval\n * - The maximum time in milliseconds to wait for a connection to succeed before closing and retrying. Accepts integer. Default: 2000.\n *\n */\n(function (global, factory) {\n    if (typeof define === 'function' && define.amd) {\n        define([], factory);\n    } else if (typeof module !== 'undefined' && module.exports){\n        module.exports = factory();\n    } else {\n        global.ReconnectingWebSocket = factory();\n    }\n})(this, function () {\n\n    if (!('WebSocket' in window)) {\n        return;\n    }\n\n    function ReconnectingWebSocket(url, protocols, options) {\n\n        // Default settings\n        var settings = {\n\n            /** Whether this instance should log debug messages. */\n            debug: false,\n\n            /** Whether or not the websocket should attempt to connect immediately upon instantiation. */\n            automaticOpen: true,\n\n            /** The number of milliseconds to delay before attempting to reconnect. */\n            reconnectInterval: 1000,\n            /** The maximum number of milliseconds to delay a reconnection attempt. */\n            maxReconnectInterval: 30000,\n            /** The rate of increase of the reconnect delay. Allows reconnect attempts to back off when problems persist. */\n            reconnectDecay: 1.5,\n\n            /** The maximum time in milliseconds to wait for a connection to succeed before closing and retrying. */\n            timeoutInterval: 2000,\n\n            /** The maximum number of reconnection attempts to make. Unlimited if null. */\n            maxReconnectAttempts: null\n        }\n        if (!options) { options = {}; }\n\n        // Overwrite and define settings with options if they exist.\n        for (var key in settings) {\n            if (typeof options[key] !== 'undefined') {\n                this[key] = options[key];\n            } else {\n                this[key] = settings[key];\n            }\n        }\n\n        // These should be treated as read-only properties\n\n        /** The URL as resolved by the constructor. This is always an absolute URL. Read only. */\n        this.url = url;\n\n        /** The number of attempted reconnects since starting, or the last successful connection. Read only. */\n        this.reconnectAttempts = 0;\n\n        /**\n         * The current state of the connection.\n         * Can be one of: WebSocket.CONNECTING, WebSocket.OPEN, WebSocket.CLOSING, WebSocket.CLOSED\n         * Read only.\n         */\n        this.readyState = WebSocket.CONNECTING;\n\n        /**\n         * A string indicating the name of the sub-protocol the server selected; this will be one of\n         * the strings specified in the protocols parameter when creating the WebSocket object.\n         * Read only.\n         */\n        this.protocol = null;\n\n        // Private state variables\n\n        var self = this;\n        var ws;\n        var forcedClose = false;\n        var timedOut = false;\n        var eventTarget = document.createElement('div');\n\n        // Wire up \"on*\" properties as event handlers\n\n        eventTarget.addEventListener('open',       function(event) { self.onopen(event); });\n        eventTarget.addEventListener('close',      function(event) { self.onclose(event); });\n        eventTarget.addEventListener('connecting', function(event) { self.onconnecting(event); });\n        eventTarget.addEventListener('message',    function(event) { self.onmessage(event); });\n        eventTarget.addEventListener('error',      function(event) { self.onerror(event); });\n\n        // Expose the API required by EventTarget\n\n        this.addEventListener = eventTarget.addEventListener.bind(eventTarget);\n        this.removeEventListener = eventTarget.removeEventListener.bind(eventTarget);\n        this.dispatchEvent = eventTarget.dispatchEvent.bind(eventTarget);\n\n        /**\n         * This function generates an event that is compatible with standard\n         * compliant browsers and IE9 - IE11\n         *\n         * This will prevent the error:\n         * Object doesn't support this action\n         *\n         * http://stackoverflow.com/questions/19345392/why-arent-my-parameters-getting-passed-through-to-a-dispatched-event/19345563#19345563\n         * @param s String The name that the event should use\n         * @param args Object an optional object that the event will use\n         */\n        function generateEvent(s, args) {\n        \tvar evt = document.createEvent(\"CustomEvent\");\n        \tevt.initCustomEvent(s, false, false, args);\n        \treturn evt;\n        };\n\n        this.open = function (reconnectAttempt) {\n            ws = new WebSocket(self.url, protocols || []);\n\n            if (reconnectAttempt) {\n                if (this.maxReconnectAttempts && this.reconnectAttempts > this.maxReconnectAttempts) {\n                    return;\n                }\n            } else {\n                eventTarget.dispatchEvent(generateEvent('connecting'));\n                this.reconnectAttempts = 0;\n            }\n\n            if (self.debug || ReconnectingWebSocket.debugAll) {\n                console.debug('ReconnectingWebSocket', 'attempt-connect', self.url);\n            }\n\n            var localWs = ws;\n            var timeout = setTimeout(function() {\n                if (self.debug || ReconnectingWebSocket.debugAll) {\n                    console.debug('ReconnectingWebSocket', 'connection-timeout', self.url);\n                }\n                timedOut = true;\n                localWs.close();\n                timedOut = false;\n            }, self.timeoutInterval);\n\n            ws.onopen = function(event) {\n                clearTimeout(timeout);\n                if (self.debug || ReconnectingWebSocket.debugAll) {\n                    console.debug('ReconnectingWebSocket', 'onopen', self.url);\n                }\n                self.protocol = ws.protocol;\n                self.readyState = WebSocket.OPEN;\n                self.reconnectAttempts = 0;\n                var e = generateEvent('open');\n                e.isReconnect = reconnectAttempt;\n                reconnectAttempt = false;\n                eventTarget.dispatchEvent(e);\n            };\n\n            ws.onclose = function(event) {\n                clearTimeout(timeout);\n                ws = null;\n                if (forcedClose) {\n                    self.readyState = WebSocket.CLOSED;\n                    eventTarget.dispatchEvent(generateEvent('close'));\n                } else {\n                    self.readyState = WebSocket.CONNECTING;\n                    var e = generateEvent('connecting');\n                    e.code = event.code;\n                    e.reason = event.reason;\n                    e.wasClean = event.wasClean;\n                    eventTarget.dispatchEvent(e);\n                    if (!reconnectAttempt && !timedOut) {\n                        if (self.debug || ReconnectingWebSocket.debugAll) {\n                            console.debug('ReconnectingWebSocket', 'onclose', self.url);\n                        }\n                        eventTarget.dispatchEvent(generateEvent('close'));\n                    }\n\n                    var timeout = self.reconnectInterval * Math.pow(self.reconnectDecay, self.reconnectAttempts);\n                    setTimeout(function() {\n                        self.reconnectAttempts++;\n                        self.open(true);\n                    }, timeout > self.maxReconnectInterval ? self.maxReconnectInterval : timeout);\n                }\n            };\n            ws.onmessage = function(event) {\n                if (self.debug || ReconnectingWebSocket.debugAll) {\n                    console.debug('ReconnectingWebSocket', 'onmessage', self.url, event.data);\n                }\n                var e = generateEvent('message');\n                e.data = event.data;\n                eventTarget.dispatchEvent(e);\n            };\n            ws.onerror = function(event) {\n                if (self.debug || ReconnectingWebSocket.debugAll) {\n                    console.debug('ReconnectingWebSocket', 'onerror', self.url, event);\n                }\n                eventTarget.dispatchEvent(generateEvent('error'));\n            };\n        }\n\n        // Whether or not to create a websocket upon instantiation\n        if (this.automaticOpen == true) {\n            this.open(false);\n        }\n\n        /**\n         * Transmits data to the server over the WebSocket connection.\n         *\n         * @param data a text string, ArrayBuffer or Blob to send to the server.\n         */\n        this.send = function(data) {\n            if (ws) {\n                if (self.debug || ReconnectingWebSocket.debugAll) {\n                    console.debug('ReconnectingWebSocket', 'send', self.url, data);\n                }\n                return ws.send(data);\n            } else {\n                throw 'INVALID_STATE_ERR : Pausing to reconnect websocket';\n            }\n        };\n\n        /**\n         * Closes the WebSocket connection or connection attempt, if any.\n         * If the connection is already CLOSED, this method does nothing.\n         */\n        this.close = function(code, reason) {\n            // Default CLOSE_NORMAL code\n            if (typeof code == 'undefined') {\n                code = 1000;\n            }\n            forcedClose = true;\n            if (ws) {\n                ws.close(code, reason);\n            }\n        };\n\n        /**\n         * Additional public API method to refresh the connection if still open (close, re-open).\n         * For example, if the app suspects bad data / missed heart beats, it can try to refresh.\n         */\n        this.refresh = function() {\n            if (ws) {\n                ws.close();\n            }\n        };\n    }\n\n    /**\n     * An event listener to be called when the WebSocket connection's readyState changes to OPEN;\n     * this indicates that the connection is ready to send and receive data.\n     */\n    ReconnectingWebSocket.prototype.onopen = function(event) {};\n    /** An event listener to be called when the WebSocket connection's readyState changes to CLOSED. */\n    ReconnectingWebSocket.prototype.onclose = function(event) {};\n    /** An event listener to be called when a connection begins being attempted. */\n    ReconnectingWebSocket.prototype.onconnecting = function(event) {};\n    /** An event listener to be called when a message is received from the server. */\n    ReconnectingWebSocket.prototype.onmessage = function(event) {};\n    /** An event listener to be called when an error occurs. */\n    ReconnectingWebSocket.prototype.onerror = function(event) {};\n\n    /**\n     * Whether all instances of ReconnectingWebSocket should log debug messages.\n     * Setting this to true is the equivalent of setting all instances of ReconnectingWebSocket.debug to true.\n     */\n    ReconnectingWebSocket.debugAll = false;\n\n    ReconnectingWebSocket.CONNECTING = WebSocket.CONNECTING;\n    ReconnectingWebSocket.OPEN = WebSocket.OPEN;\n    ReconnectingWebSocket.CLOSING = WebSocket.CLOSING;\n    ReconnectingWebSocket.CLOSED = WebSocket.CLOSED;\n\n    return ReconnectingWebSocket;\n});\n","(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n// MIT License:\n//\n// Copyright (c) 2010-2012, Joe Walnes\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n/**\n * This behaves like a WebSocket in every way, except if it fails to connect,\n * or it gets disconnected, it will repeatedly poll until it successfully connects\n * again.\n *\n * It is API compatible, so when you have:\n *   ws = new WebSocket('ws://....');\n * you can replace with:\n *   ws = new ReconnectingWebSocket('ws://....');\n *\n * The event stream will typically look like:\n *  onconnecting\n *  onopen\n *  onmessage\n *  onmessage\n *  onclose // lost connection\n *  onconnecting\n *  onopen  // sometime later...\n *  onmessage\n *  onmessage\n *  etc...\n *\n * It is API compatible with the standard WebSocket API, apart from the following members:\n *\n * - `bufferedAmount`\n * - `extensions`\n * - `binaryType`\n *\n * Latest version: https://github.com/joewalnes/reconnecting-websocket/\n * - Joe Walnes\n *\n * Syntax\n * ======\n * var socket = new ReconnectingWebSocket(url, protocols, options);\n *\n * Parameters\n * ==========\n * url - The url you are connecting to.\n * protocols - Optional string or array of protocols.\n * options - See below\n *\n * Options\n * =======\n * Options can either be passed upon instantiation or set after instantiation:\n *\n * var socket = new ReconnectingWebSocket(url, null, { debug: true, reconnectInterval: 4000 });\n *\n * or\n *\n * var socket = new ReconnectingWebSocket(url);\n * socket.debug = true;\n * socket.reconnectInterval = 4000;\n *\n * debug\n * - Whether this instance should log debug messages. Accepts true or false. Default: false.\n *\n * automaticOpen\n * - Whether or not the websocket should attempt to connect immediately upon instantiation. The socket can be manually opened or closed at any time using ws.open() and ws.close().\n *\n * reconnectInterval\n * - The number of milliseconds to delay before attempting to reconnect. Accepts integer. Default: 1000.\n *\n * maxReconnectInterval\n * - The maximum number of milliseconds to delay a reconnection attempt. Accepts integer. Default: 30000.\n *\n * reconnectDecay\n * - The rate of increase of the reconnect delay. Allows reconnect attempts to back off when problems persist. Accepts integer or float. Default: 1.5.\n *\n * timeoutInterval\n * - The maximum time in milliseconds to wait for a connection to succeed before closing and retrying. Accepts integer. Default: 2000.\n *\n */\n(function (global, factory) {\n    if (typeof define === 'function' && define.amd) {\n        define([], factory);\n    } else if (typeof module !== 'undefined' && module.exports){\n        module.exports = factory();\n    } else {\n        global.ReconnectingWebSocket = factory();\n    }\n})(this, function () {\n\n    if (!('WebSocket' in window)) {\n        return;\n    }\n\n    function ReconnectingWebSocket(url, protocols, options) {\n\n        // Default settings\n        var settings = {\n\n            /** Whether this instance should log debug messages. */\n            debug: false,\n\n            /** Whether or not the websocket should attempt to connect immediately upon instantiation. */\n            automaticOpen: true,\n\n            /** The number of milliseconds to delay before attempting to reconnect. */\n            reconnectInterval: 1000,\n            /** The maximum number of milliseconds to delay a reconnection attempt. */\n            maxReconnectInterval: 30000,\n            /** The rate of increase of the reconnect delay. Allows reconnect attempts to back off when problems persist. */\n            reconnectDecay: 1.5,\n\n            /** The maximum time in milliseconds to wait for a connection to succeed before closing and retrying. */\n            timeoutInterval: 2000,\n\n            /** The maximum number of reconnection attempts to make. Unlimited if null. */\n            maxReconnectAttempts: null\n        }\n        if (!options) { options = {}; }\n\n        // Overwrite and define settings with options if they exist.\n        for (var key in settings) {\n            if (typeof options[key] !== 'undefined') {\n                this[key] = options[key];\n            } else {\n                this[key] = settings[key];\n            }\n        }\n\n        // These should be treated as read-only properties\n\n        /** The URL as resolved by the constructor. This is always an absolute URL. Read only. */\n        this.url = url;\n\n        /** The number of attempted reconnects since starting, or the last successful connection. Read only. */\n        this.reconnectAttempts = 0;\n\n        /**\n         * The current state of the connection.\n         * Can be one of: WebSocket.CONNECTING, WebSocket.OPEN, WebSocket.CLOSING, WebSocket.CLOSED\n         * Read only.\n         */\n        this.readyState = WebSocket.CONNECTING;\n\n        /**\n         * A string indicating the name of the sub-protocol the server selected; this will be one of\n         * the strings specified in the protocols parameter when creating the WebSocket object.\n         * Read only.\n         */\n        this.protocol = null;\n\n        // Private state variables\n\n        var self = this;\n        var ws;\n        var forcedClose = false;\n        var timedOut = false;\n        var eventTarget = document.createElement('div');\n\n        // Wire up \"on*\" properties as event handlers\n\n        eventTarget.addEventListener('open',       function(event) { self.onopen(event); });\n        eventTarget.addEventListener('close',      function(event) { self.onclose(event); });\n        eventTarget.addEventListener('connecting', function(event) { self.onconnecting(event); });\n        eventTarget.addEventListener('message',    function(event) { self.onmessage(event); });\n        eventTarget.addEventListener('error',      function(event) { self.onerror(event); });\n\n        // Expose the API required by EventTarget\n\n        this.addEventListener = eventTarget.addEventListener.bind(eventTarget);\n        this.removeEventListener = eventTarget.removeEventListener.bind(eventTarget);\n        this.dispatchEvent = eventTarget.dispatchEvent.bind(eventTarget);\n\n        /**\n         * This function generates an event that is compatible with standard\n         * compliant browsers and IE9 - IE11\n         *\n         * This will prevent the error:\n         * Object doesn't support this action\n         *\n         * http://stackoverflow.com/questions/19345392/why-arent-my-parameters-getting-passed-through-to-a-dispatched-event/19345563#19345563\n         * @param s String The name that the event should use\n         * @param args Object an optional object that the event will use\n         */\n        function generateEvent(s, args) {\n        \tvar evt = document.createEvent(\"CustomEvent\");\n        \tevt.initCustomEvent(s, false, false, args);\n        \treturn evt;\n        };\n\n        this.open = function (reconnectAttempt) {\n            ws = new WebSocket(self.url, protocols || []);\n\n            if (reconnectAttempt) {\n                if (this.maxReconnectAttempts && this.reconnectAttempts > this.maxReconnectAttempts) {\n                    return;\n                }\n            } else {\n                eventTarget.dispatchEvent(generateEvent('connecting'));\n                this.reconnectAttempts = 0;\n            }\n\n            if (self.debug || ReconnectingWebSocket.debugAll) {\n                console.debug('ReconnectingWebSocket', 'attempt-connect', self.url);\n            }\n\n            var localWs = ws;\n            var timeout = setTimeout(function() {\n                if (self.debug || ReconnectingWebSocket.debugAll) {\n                    console.debug('ReconnectingWebSocket', 'connection-timeout', self.url);\n                }\n                timedOut = true;\n                localWs.close();\n                timedOut = false;\n            }, self.timeoutInterval);\n\n            ws.onopen = function(event) {\n                clearTimeout(timeout);\n                if (self.debug || ReconnectingWebSocket.debugAll) {\n                    console.debug('ReconnectingWebSocket', 'onopen', self.url);\n                }\n                self.protocol = ws.protocol;\n                self.readyState = WebSocket.OPEN;\n                self.reconnectAttempts = 0;\n                var e = generateEvent('open');\n                e.isReconnect = reconnectAttempt;\n                reconnectAttempt = false;\n                eventTarget.dispatchEvent(e);\n            };\n\n            ws.onclose = function(event) {\n                clearTimeout(timeout);\n                ws = null;\n                if (forcedClose) {\n                    self.readyState = WebSocket.CLOSED;\n                    eventTarget.dispatchEvent(generateEvent('close'));\n                } else {\n                    self.readyState = WebSocket.CONNECTING;\n                    var e = generateEvent('connecting');\n                    e.code = event.code;\n                    e.reason = event.reason;\n                    e.wasClean = event.wasClean;\n                    eventTarget.dispatchEvent(e);\n                    if (!reconnectAttempt && !timedOut) {\n                        if (self.debug || ReconnectingWebSocket.debugAll) {\n                            console.debug('ReconnectingWebSocket', 'onclose', self.url);\n                        }\n                        eventTarget.dispatchEvent(generateEvent('close'));\n                    }\n\n                    var timeout = self.reconnectInterval * Math.pow(self.reconnectDecay, self.reconnectAttempts);\n                    setTimeout(function() {\n                        self.reconnectAttempts++;\n                        self.open(true);\n                    }, timeout > self.maxReconnectInterval ? self.maxReconnectInterval : timeout);\n                }\n            };\n            ws.onmessage = function(event) {\n                if (self.debug || ReconnectingWebSocket.debugAll) {\n                    console.debug('ReconnectingWebSocket', 'onmessage', self.url, event.data);\n                }\n                var e = generateEvent('message');\n                e.data = event.data;\n                eventTarget.dispatchEvent(e);\n            };\n            ws.onerror = function(event) {\n                if (self.debug || ReconnectingWebSocket.debugAll) {\n                    console.debug('ReconnectingWebSocket', 'onerror', self.url, event);\n                }\n                eventTarget.dispatchEvent(generateEvent('error'));\n            };\n        }\n\n        // Whether or not to create a websocket upon instantiation\n        if (this.automaticOpen == true) {\n            this.open(false);\n        }\n\n        /**\n         * Transmits data to the server over the WebSocket connection.\n         *\n         * @param data a text string, ArrayBuffer or Blob to send to the server.\n         */\n        this.send = function(data) {\n            if (ws) {\n                if (self.debug || ReconnectingWebSocket.debugAll) {\n                    console.debug('ReconnectingWebSocket', 'send', self.url, data);\n                }\n                return ws.send(data);\n            } else {\n                throw 'INVALID_STATE_ERR : Pausing to reconnect websocket';\n            }\n        };\n\n        /**\n         * Closes the WebSocket connection or connection attempt, if any.\n         * If the connection is already CLOSED, this method does nothing.\n         */\n        this.close = function(code, reason) {\n            // Default CLOSE_NORMAL code\n            if (typeof code == 'undefined') {\n                code = 1000;\n            }\n            forcedClose = true;\n            if (ws) {\n                ws.close(code, reason);\n            }\n        };\n\n        /**\n         * Additional public API method to refresh the connection if still open (close, re-open).\n         * For example, if the app suspects bad data / missed heart beats, it can try to refresh.\n         */\n        this.refresh = function() {\n            if (ws) {\n                ws.close();\n            }\n        };\n    }\n\n    /**\n     * An event listener to be called when the WebSocket connection's readyState changes to OPEN;\n     * this indicates that the connection is ready to send and receive data.\n     */\n    ReconnectingWebSocket.prototype.onopen = function(event) {};\n    /** An event listener to be called when the WebSocket connection's readyState changes to CLOSED. */\n    ReconnectingWebSocket.prototype.onclose = function(event) {};\n    /** An event listener to be called when a connection begins being attempted. */\n    ReconnectingWebSocket.prototype.onconnecting = function(event) {};\n    /** An event listener to be called when a message is received from the server. */\n    ReconnectingWebSocket.prototype.onmessage = function(event) {};\n    /** An event listener to be called when an error occurs. */\n    ReconnectingWebSocket.prototype.onerror = function(event) {};\n\n    /**\n     * Whether all instances of ReconnectingWebSocket should log debug messages.\n     * Setting this to true is the equivalent of setting all instances of ReconnectingWebSocket.debug to true.\n     */\n    ReconnectingWebSocket.debugAll = false;\n\n    ReconnectingWebSocket.CONNECTING = WebSocket.CONNECTING;\n    ReconnectingWebSocket.OPEN = WebSocket.OPEN;\n    ReconnectingWebSocket.CLOSING = WebSocket.CLOSING;\n    ReconnectingWebSocket.CLOSED = WebSocket.CLOSED;\n\n    return ReconnectingWebSocket;\n});\n\n},{}],2:[function(require,module,exports){\n\"use strict\";\r\n\r\nvar ReconnectingWebSocket = require('reconnectingwebsocket');\r\n\r\nmodule.exports = function (codeName) {\r\n  var DataClient = {};\r\n\r\n  function Peer(name, color) {\r\n    this.id = null;\r\n    this.name = name;\r\n    this.color = color;\r\n  }\r\n\r\n  // Consumer should set this to unique names in page if there are multiple clients\r\n  DataClient.codeName = \"dc\";\r\n\r\n  DataClient.color = \"red\";\r\n  DataClient.me = null;\r\n  DataClient.connected = false;\r\n  DataClient.version = null;\r\n  DataClient.peers = [];\r\n\r\n  DataClient.connect = function (name) {\r\n    DataClient.me = new Peer(name, DataClient.color);\r\n    // Create browserchannel socket\r\n    var wsAddr = ((location.protocol === 'https:') ? 'wss' : 'ws') + '://' + window.location.host + '/data';\r\n    //DataClient.socket = new ReconnectingWebSocket(wsAddr);\r\n    DataClient.socket = new WebSocket(wsAddr);\r\n    initSocketHandlers();\r\n  }\r\n\r\n  DataClient.disconnect = function () {\r\n    DataClient.socket.close();\r\n    delete DataClient.socket;\r\n    delete DataClient.me;\r\n    DataClient.peers = [];\r\n  }\r\n\r\n  // Send my details\r\n  DataClient.sendMyDetails = function () {\r\n    var msgObj = {\r\n      msg: \"details\",\r\n      data: DataClient.me\r\n    };\r\n    DataClient.socket.send(JSON.stringify(msgObj));\r\n  };\r\n\r\n  // Store and send new selection\r\n  DataClient.selectionChanged = function (range) {\r\n    if (!DataClient.me) return;\r\n    DataClient.me.range = range;\r\n    var msgObj = {\r\n      msg: \"selection\",\r\n      data: DataClient.me.range\r\n    };\r\n    DataClient.socket.send(JSON.stringify(msgObj));\r\n  }\r\n\r\n  // Local editor content changed (user input)\r\n  DataClient.contentChanged = function (delta, oldDelta, source) {\r\n    if (source != \"user\") return;\r\n\r\n    if (DataClient.me.range && DataClient.me.range.length) {\r\n      DataClient.me.range.index += DataClient.me.range.length;\r\n      DataClient.me.range.length = 0;\r\n      DataClient.selectionChanged();\r\n    }\r\n    var msgObj = {\r\n      msg: \"delta\",\r\n      data: delta\r\n    };\r\n    DataClient.socket.send(JSON.stringify(msgObj));\r\n  }\r\n\r\n  // Server sent selection update for one peer\r\n  function onMsgSelection(data) {\r\n    console.log(\"[DataClient] Peer selection received.\", data);\r\n    var peer = DataClient.peers.find((p) => { return p.id == data.id; });\r\n    if (!peer) return;\r\n    peer.range = data.range;\r\n    document.dispatchEvent(new CustomEvent('dataclient-cursor-update', {\r\n      detail: {\r\n        sender: DataClient,\r\n        source: peer\r\n      }\r\n    }));\r\n  }\r\n\r\n  // Server sent peer list\r\n  function onMsgPeers(data) {\r\n    var source = {};\r\n    var forceSendDetails = false;\r\n    var reportNewPeers = true;\r\n\r\n    if (!DataClient.me.id) forceSendDetails = true;\r\n    // Refresh local connection ID (we get it assigned from server)\r\n    DataClient.me.id = data.id;\r\n\r\n    if (forceSendDetails) {\r\n      DataClient.sendMyDetails();\r\n      return;\r\n    }\r\n\r\n    // Find removed peers\r\n    for (var i = 0; i < DataClient.peers.length; i++) {\r\n      var receivedPeer = data.peers.find((p) => { return p.id == DataClient.peers[i].id; });\r\n\r\n      if (!receivedPeer) {\r\n        console.log('[DataClient] Peer disconnected:', DataClient.peers[i]);\r\n\r\n        // If the source connection was removed set it\r\n        if (data.sourceId == DataClient.peers[i])\r\n          source = DataClient.peers[i];\r\n      } else if (receivedPeer.name && !DataClient.peers[i].name) {\r\n        console.log('[DataClient] User ' + receivedPeer.id + ' set username:', receivedPeer.name);\r\n        console.log('[DataClient] Peers after username update:', data.peers);\r\n      }\r\n    }\r\n\r\n    if (DataClient.peers.length == 0 && data.peers.length != 0) {\r\n      console.log('[DataClient] Initial list of peers received from server:', data.peers);\r\n      reportNewPeers = false;\r\n    }\r\n\r\n    for (var i = 0; i < data.peers.length; i++) {\r\n      // Set the source if it's still an active peers\r\n      if (data.sourceId == data.peers[i].id)\r\n        source = data.peers[i];\r\n\r\n      if (reportNewPeers && !DataClient.peers.find((p) => { return p.id == data.peers[i].id })) {\r\n        console.log('[DataClient] Peer connected:', data.peers[i]);\r\n        console.log('[DataClient] Peers after new user:', data.peers);\r\n      }\r\n    }\r\n\r\n    // Update peers array\r\n    DataClient.peers = data.peers;\r\n\r\n    // Tell consumer\r\n    var peerList = [];\r\n    DataClient.peers.forEach((p) => {\r\n      peerList.push({ id: p.id, name: p.name, color: p.color });\r\n    });\r\n    document.dispatchEvent(new CustomEvent('dataclient-peers', {\r\n      detail: {\r\n        sender: DataClient,\r\n        source: source,\r\n        peers: peerList\r\n      }\r\n    }));\r\n  }\r\n\r\n  function onMsgContent(data) {\r\n    console.log('[DataClient] Received document content.');\r\n    DataClient.version = data.version;\r\n    document.dispatchEvent(new CustomEvent('dataclient-content', {\r\n      detail: {\r\n        sender: DataClient,\r\n        data: data.content\r\n      }\r\n    }));\r\n  }\r\n\r\n  function onMsgDelta(data) {\r\n    console.log('[DataClient] Received document delta.');\r\n    DataClient.version = data.version;\r\n    document.dispatchEvent(new CustomEvent('dataclient-delta', {\r\n      detail: {\r\n        sender: DataClient,\r\n        data: data.delta\r\n      }\r\n    }));\r\n  }\r\n\r\n  function initSocketHandlers() {\r\n\r\n    // Send initial message to register the client, and\r\n    // retrieve a list of current clients so we can set a colour.\r\n    DataClient.socket.onopen = function () {\r\n      DataClient.connected = true;\r\n      DataClient.sendMyDetails();\r\n      document.dispatchEvent(new CustomEvent('dataclient-connected', {\r\n        detail: {\r\n          sender: DataClient\r\n        }\r\n      }));\r\n    };\r\n\r\n    DataClient.socket.onmessage = function (message) {\r\n      var msgObj = JSON.parse(message.data);\r\n      if (msgObj.msg == \"peers\") onMsgPeers(msgObj.data);\r\n      else if (msgObj.msg == \"selection\") onMsgSelection(msgObj.data);\r\n      else if (msgObj.msg == \"content\") onMsgContent(msgObj.data);\r\n      else if (msgObj.msg == \"delta\") onMsgDelta(msgObj.data);\r\n    };\r\n\r\n    DataClient.socket.onclose = function (event) {\r\n      console.log('[DataClient] Socket closed. Event:', event);\r\n      DataClient.connected = false;\r\n      document.dispatchEvent(new CustomEvent('dataclient-disconnected', {\r\n        detail: {\r\n          sender: DataClient\r\n        }\r\n      }));\r\n    };\r\n\r\n    DataClient.socket.onerror = function (event) {\r\n      console.log('[DataClient] Error on socket. Event:', event);\r\n    };\r\n  }\r\n\r\n  return DataClient;\r\n}\r\n\r\n\n},{\"reconnectingwebsocket\":1}],3:[function(require,module,exports){\n\"use strict\";\r\n\r\nconst colors = [\"red\", \"blue\", \"violet\", \"green\", \"orchid\", \"orange\"];\r\n\r\nvar utils = require('./utils');\r\nvar dc1 = require('./data-client')();\r\ndc1.codeName = \"dc1\";\r\nvar dc2 = require('./data-client')();\r\ndc2.codeName = \"dc2\";\r\nvar q1, q2;     // Quill instances\r\nvar cm1, cm2;   // Cursors modules\r\n\r\nvar quillParams = {\r\n  theme: 'snow',\r\n  placeholder: \"Let's write a story together.\",\r\n  modules: {\r\n    cursors: {\r\n      autoRegisterListener: false\r\n    },\r\n    history: {\r\n      userOnly: true\r\n    }\r\n  },\r\n  readOnly: true\r\n};\r\n\r\n$(document).ready(function () {\r\n  Quill.register('modules/cursors', QuillCursors);\r\n  q1 = new Quill('#editorL', quillParams);\r\n  q2 = new Quill('#editorR', quillParams);\r\n  $(\".editorWrap\").removeClass(\"hidden\");\r\n  wireupColors();\r\n  wireupConnectEvents([[dc1, $(\".half.left\")], [dc2, $(\".half.right\")]]);\r\n  wireupCursors();\r\n  wireupContent();\r\n});\r\n\r\nfunction wireupColors() {\r\n  function updateColor(elmTxt, elmBtn, dc) {\r\n    colors.forEach(x => elmBtn.removeClass(x));\r\n    var ix = Math.abs(utils.hash(elmTxt.val())) % 6;\r\n    elmBtn.addClass(colors[ix]);\r\n    dc.color = colors[ix];\r\n  }\r\n  var elmTxtL = $(\".half.left .connect input[type='text']\");\r\n  var elmBtnL = $(\".half.left .connect input[type='button']\");\r\n  updateColor(elmTxtL, elmBtnL, dc1);\r\n  elmTxtL.on(\"input\", function () {\r\n    updateColor(elmTxtL, elmBtnL, dc1);\r\n  });\r\n  var elmTxtR = $(\".half.right .connect input[type='text']\");\r\n  var elmBtnR = $(\".half.right .connect input[type='button']\");\r\n  updateColor(elmTxtR, elmBtnR, dc2);\r\n  elmTxtR.on(\"input\", function () {\r\n    updateColor(elmTxtR, elmBtnR, dc2);\r\n  });\r\n}\r\n\r\nfunction wireupContent() {\r\n  q1.on('text-change', function (delta, oldDelta, source) {\r\n    //console.log(\"[shuang] q1 text-change\");\r\n    //console.log(\"[shuang] delta:\", delta);\r\n    //console.log(\"[shuang] source:\", source);\r\n    dc1.contentChanged(delta, oldDelta, source);\r\n  });\r\n  q2.on('text-change', function (delta, oldDelta, source) {\r\n    //console.log(\"[shuang] q2 text-change\");\r\n    //console.log(\"[shuang] delta:\", delta);\r\n    //console.log(\"[shuang] source:\", source);\r\n    dc2.contentChanged(delta, oldDelta, source);\r\n  });\r\n\r\n  document.addEventListener('dataclient-content', function (e) {\r\n    var q;\r\n    if (e.detail.sender.codeName == \"dc1\") q = q1;\r\n    else if (e.detail.sender.codeName == \"dc2\") q = q2;\r\n    q.setContents(e.detail.data);\r\n  });\r\n  document.addEventListener('dataclient-delta', function (e) {\r\n    var q;\r\n    if (e.detail.sender.codeName == \"dc1\") q = q1;\r\n    else if (e.detail.sender.codeName == \"dc2\") q = q2;\r\n    q.updateContents(e.detail.data);\r\n  });\r\n}\r\n\r\nfunction wireupCursors() {\r\n  cm1 = q1.getModule(\"cursors\");\r\n  cm1.registerTextChangeListener();\r\n  cm2 = q2.getModule(\"cursors\");\r\n  cm2.registerTextChangeListener();\r\n\r\n  //var debouncedSendCursorData = utils.debounce(function () {\r\n  //  var r1 = q1.getSelection();\r\n  //  if (r1) {\r\n  //    console.log('[shuang] Stopped typing, sending a cursor update/refresh.');\r\n  //    sendCursorData(r1);\r\n  //  }\r\n  //  var r2 = q2.getSelection();\r\n  //  if (r2) {\r\n  //    console.log('[shuang] Stopped typing, sending a cursor update/refresh.');\r\n  //    sendCursorData(r2);\r\n  //  }\r\n  //}, 1500);\r\n  //doc.on('nothing pending', debouncedSendCursorData);\r\n\r\n  q1.on('selection-change', function (range, oldRange, source) {\r\n    dc1.selectionChanged(range);\r\n  });\r\n\r\n  q2.on('selection-change', function (range, oldRange, source) {\r\n    dc2.selectionChanged(range);\r\n  });\r\n\r\n  document.addEventListener('dataclient-cursor-update', function (e) {\r\n    if (e.detail.sender.codeName == \"dc1\")\r\n      updateCursors(e.detail.source, cm1, dc1);\r\n    else if (e.detail.sender.codeName == \"dc2\")\r\n      updateCursors(e.detail.source, cm2, dc2);\r\n  });\r\n}\r\n\r\n\r\nfunction updateCursors(source, cm, dc) {\r\n  var activePeers = {};\r\n  // If cursors module has no cursors yet, time to show them all.\r\n  // Otherwise, only update sender's cursor.\r\n  var updateAll = Object.keys(cm.cursors).length == 0;\r\n\r\n  dc.peers.forEach((peer) => {\r\n    if (peer.id == dc.me.id) return;\r\n    // Update cursor that sent the update, or update all if we're initializing\r\n    if ((peer.id == source.id || updateAll) && peer.range) {\r\n      cm.setCursor(peer.id, peer.range, peer.name, peer.color);\r\n    }\r\n    // Seen, hence active\r\n    activePeers[peer.id] = peer;\r\n  });\r\n\r\n  // Clear cursors if peer is gone\r\n  Object.keys(cm.cursors).forEach((id) => {\r\n    if (!activePeers[id]) {\r\n      cm.removeCursor(id);\r\n    }\r\n  });\r\n}\r\n\r\n\r\nfunction wireupConnectEvents(clients) {\r\n  clients.forEach((x) => {\r\n    var dc = x[0];\r\n    var elm = x[1];\r\n    var elmButton = elm.find(\".connect input[type='button']\");\r\n    var elmTxt = elm.find(\".connect input[type='text']\");\r\n    elmButton.click(function () {\r\n      if ($(this).hasClass(\"disabled\")) return;\r\n      if (dc.connected) dc.disconnect();\r\n      else {\r\n        var name = elmTxt.val();\r\n        var color = dc.codeName == \"dc1\" ? \"red\" : \"blue\";\r\n        dc.connect(name);\r\n      }\r\n      $(this).addClass(\"disabled\");\r\n      elmTxt.prop(\"readonly\", true);\r\n    });\r\n  });\r\n  document.addEventListener(\"dataclient-connected\", function (e, f) {\r\n    var elmBtn = null;\r\n    if (e.detail.sender.codeName == \"dc1\") {\r\n      elmBtn = $(\".half.left .connect input[type='button']\");\r\n      q1.enable();\r\n      updateCursors(dc1.me, cm1, dc1);\r\n    }\r\n    else {\r\n      elmBtn = $(\".half.right .connect input[type='button']\");\r\n      q2.enable();\r\n      updateCursors(dc2.me, cm2, dc2);\r\n    }\r\n    elmBtn.attr(\"value\", \"Disconnect\");\r\n    elmBtn.removeClass(\"disabled\");\r\n  });\r\n  document.addEventListener(\"dataclient-disconnected\", function (e) {\r\n    var elmBtn;\r\n    var elmTxt;\r\n    if (e.detail.sender.codeName == \"dc1\") {\r\n      elmBtn = $(\".half.left .connect input[type='button']\");\r\n      elmTxt = $(\".half.left .connect input[type='text']\");\r\n      q1.disable();\r\n    }\r\n    else {\r\n      elmBtn = $(\".half.right .connect input[type='button']\");\r\n      elmTxt = $(\".half.right .connect input[type='text']\");\r\n      q2.disable();\r\n    }\r\n    elmBtn.attr(\"value\", \"Connect\");\r\n    elmBtn.removeClass(\"disabled\");\r\n    elmTxt.prop(\"readonly\", false);\r\n  });\r\n  document.addEventListener(\"dataclient-peers\", function (e) {\r\n    var dc, cm;\r\n    if (e.detail.sender.codeName == \"dc1\") { dc = dc1; cm = cm1; }\r\n    else { dc = dc2; cm = cm2; }\r\n    updateCursors(e.detail.source, cm, dc);\r\n    var html = \"\";\r\n    console.log(e.detail.peers);\r\n    e.detail.peers.forEach((p) => {\r\n      html += \"<p class='\" + p.color + \"'>\";\r\n      html += utils.esc(p.name);\r\n      if (p.id == dc.me.id) html += \" (me)\";\r\n      html += \"</p>\";\r\n    });\r\n    $(\"#peerlist\").html(html);\r\n  });\r\n\r\n}\r\n\r\n\n},{\"./data-client\":2,\"./utils\":4}],4:[function(require,module,exports){\n// Returns a function, that, as long as it continues to be invoked, will not\r\n// be triggered. The function will be called after it stops being called for\r\n// N milliseconds. If `immediate` is passed, trigger the function on the\r\n// leading edge, instead of the trailing.\r\nexports.debounce = function (func, wait, immediate) {\r\n  var timeout;\r\n  return function () {\r\n    var context = this,\r\n      args = arguments;\r\n    var later = function () {\r\n      timeout = null;\r\n      if (!immediate) func.apply(context, args);\r\n    };\r\n    var callNow = immediate && !timeout;\r\n    clearTimeout(timeout);\r\n    timeout = setTimeout(later, wait);\r\n    if (callNow) func.apply(context, args);\r\n  };\r\n};\r\n\r\nexports.hash = function (str) {\r\n  var hash = 0, i = 0, len = str.length;\r\n  while (i < len) {\r\n    hash = ((hash << 5) - hash + str.charCodeAt(i++)) << 0;\r\n  }\r\n  return hash;\r\n};\r\n\r\nexports.esc = function (s) {\r\n  return s.replace(/&/g, '&amp;')\r\n    .replace(/\"/g, '&quot;')\r\n    .replace(/</g, '&lt;')\r\n    .replace(/>/g, '&gt;');\r\n}\r\n\n},{}]},{},[3])\n\n","\"use strict\";\r\n\r\nvar ReconnectingWebSocket = require('reconnectingwebsocket');\r\n\r\nmodule.exports = function (codeName) {\r\n  var DataClient = {};\r\n\r\n  function Peer(name, color) {\r\n    this.id = null;\r\n    this.name = name;\r\n    this.color = color;\r\n  }\r\n\r\n  // Consumer should set this to unique names in page if there are multiple clients\r\n  DataClient.codeName = \"dc\";\r\n\r\n  DataClient.color = \"red\";\r\n  DataClient.me = null;\r\n  DataClient.connected = false;\r\n  DataClient.version = null;\r\n  DataClient.peers = [];\r\n\r\n  DataClient.connect = function (name) {\r\n    DataClient.me = new Peer(name, DataClient.color);\r\n    // Create browserchannel socket\r\n    var wsAddr = ((location.protocol === 'https:') ? 'wss' : 'ws') + '://' + window.location.host + '/data';\r\n    //DataClient.socket = new ReconnectingWebSocket(wsAddr);\r\n    DataClient.socket = new WebSocket(wsAddr);\r\n    initSocketHandlers();\r\n  }\r\n\r\n  DataClient.disconnect = function () {\r\n    DataClient.socket.close();\r\n    delete DataClient.socket;\r\n    delete DataClient.me;\r\n    DataClient.peers = [];\r\n  }\r\n\r\n  // Send my details\r\n  DataClient.sendMyDetails = function () {\r\n    var msgObj = {\r\n      msg: \"details\",\r\n      data: DataClient.me\r\n    };\r\n    DataClient.socket.send(JSON.stringify(msgObj));\r\n  };\r\n\r\n  // Store and send new selection\r\n  DataClient.selectionChanged = function (range) {\r\n    if (!DataClient.me) return;\r\n    DataClient.me.range = range;\r\n    var msgObj = {\r\n      msg: \"selection\",\r\n      data: DataClient.me.range\r\n    };\r\n    DataClient.socket.send(JSON.stringify(msgObj));\r\n  }\r\n\r\n  // Local editor content changed (user input)\r\n  DataClient.contentChanged = function (delta, oldDelta, source) {\r\n    if (source != \"user\") return;\r\n\r\n    if (DataClient.me.range && DataClient.me.range.length) {\r\n      DataClient.me.range.index += DataClient.me.range.length;\r\n      DataClient.me.range.length = 0;\r\n      DataClient.selectionChanged();\r\n    }\r\n    var msgObj = {\r\n      msg: \"delta\",\r\n      data: delta\r\n    };\r\n    DataClient.socket.send(JSON.stringify(msgObj));\r\n  }\r\n\r\n  // Server sent selection update for one peer\r\n  function onMsgSelection(data) {\r\n    console.log(\"[DataClient] Peer selection received.\", data);\r\n    var peer = DataClient.peers.find((p) => { return p.id == data.id; });\r\n    if (!peer) return;\r\n    peer.range = data.range;\r\n    document.dispatchEvent(new CustomEvent('dataclient-cursor-update', {\r\n      detail: {\r\n        sender: DataClient,\r\n        source: peer\r\n      }\r\n    }));\r\n  }\r\n\r\n  // Server sent peer list\r\n  function onMsgPeers(data) {\r\n    var source = {};\r\n    var forceSendDetails = false;\r\n    var reportNewPeers = true;\r\n\r\n    if (!DataClient.me.id) forceSendDetails = true;\r\n    // Refresh local connection ID (we get it assigned from server)\r\n    DataClient.me.id = data.id;\r\n\r\n    if (forceSendDetails) {\r\n      DataClient.sendMyDetails();\r\n      return;\r\n    }\r\n\r\n    // Find removed peers\r\n    for (var i = 0; i < DataClient.peers.length; i++) {\r\n      var receivedPeer = data.peers.find((p) => { return p.id == DataClient.peers[i].id; });\r\n\r\n      if (!receivedPeer) {\r\n        console.log('[DataClient] Peer disconnected:', DataClient.peers[i]);\r\n\r\n        // If the source connection was removed set it\r\n        if (data.sourceId == DataClient.peers[i])\r\n          source = DataClient.peers[i];\r\n      } else if (receivedPeer.name && !DataClient.peers[i].name) {\r\n        console.log('[DataClient] User ' + receivedPeer.id + ' set username:', receivedPeer.name);\r\n        console.log('[DataClient] Peers after username update:', data.peers);\r\n      }\r\n    }\r\n\r\n    if (DataClient.peers.length == 0 && data.peers.length != 0) {\r\n      console.log('[DataClient] Initial list of peers received from server:', data.peers);\r\n      reportNewPeers = false;\r\n    }\r\n\r\n    for (var i = 0; i < data.peers.length; i++) {\r\n      // Set the source if it's still an active peers\r\n      if (data.sourceId == data.peers[i].id)\r\n        source = data.peers[i];\r\n\r\n      if (reportNewPeers && !DataClient.peers.find((p) => { return p.id == data.peers[i].id })) {\r\n        console.log('[DataClient] Peer connected:', data.peers[i]);\r\n        console.log('[DataClient] Peers after new user:', data.peers);\r\n      }\r\n    }\r\n\r\n    // Update peers array\r\n    DataClient.peers = data.peers;\r\n\r\n    // Tell consumer\r\n    var peerList = [];\r\n    DataClient.peers.forEach((p) => {\r\n      peerList.push({ id: p.id, name: p.name, color: p.color });\r\n    });\r\n    document.dispatchEvent(new CustomEvent('dataclient-peers', {\r\n      detail: {\r\n        sender: DataClient,\r\n        source: source,\r\n        peers: peerList\r\n      }\r\n    }));\r\n  }\r\n\r\n  function onMsgContent(data) {\r\n    console.log('[DataClient] Received document content.');\r\n    DataClient.version = data.version;\r\n    document.dispatchEvent(new CustomEvent('dataclient-content', {\r\n      detail: {\r\n        sender: DataClient,\r\n        data: data.content\r\n      }\r\n    }));\r\n  }\r\n\r\n  function onMsgDelta(data) {\r\n    console.log('[DataClient] Received document delta.');\r\n    DataClient.version = data.version;\r\n    document.dispatchEvent(new CustomEvent('dataclient-delta', {\r\n      detail: {\r\n        sender: DataClient,\r\n        data: data.delta\r\n      }\r\n    }));\r\n  }\r\n\r\n  function initSocketHandlers() {\r\n\r\n    // Send initial message to register the client, and\r\n    // retrieve a list of current clients so we can set a colour.\r\n    DataClient.socket.onopen = function () {\r\n      DataClient.connected = true;\r\n      DataClient.sendMyDetails();\r\n      document.dispatchEvent(new CustomEvent('dataclient-connected', {\r\n        detail: {\r\n          sender: DataClient\r\n        }\r\n      }));\r\n    };\r\n\r\n    DataClient.socket.onmessage = function (message) {\r\n      var msgObj = JSON.parse(message.data);\r\n      if (msgObj.msg == \"peers\") onMsgPeers(msgObj.data);\r\n      else if (msgObj.msg == \"selection\") onMsgSelection(msgObj.data);\r\n      else if (msgObj.msg == \"content\") onMsgContent(msgObj.data);\r\n      else if (msgObj.msg == \"delta\") onMsgDelta(msgObj.data);\r\n    };\r\n\r\n    DataClient.socket.onclose = function (event) {\r\n      console.log('[DataClient] Socket closed. Event:', event);\r\n      DataClient.connected = false;\r\n      document.dispatchEvent(new CustomEvent('dataclient-disconnected', {\r\n        detail: {\r\n          sender: DataClient\r\n        }\r\n      }));\r\n    };\r\n\r\n    DataClient.socket.onerror = function (event) {\r\n      console.log('[DataClient] Error on socket. Event:', event);\r\n    };\r\n  }\r\n\r\n  return DataClient;\r\n}\r\n\r\n","\"use strict\";\r\n\r\nconst colors = [\"red\", \"blue\", \"violet\", \"green\", \"orchid\", \"orange\"];\r\n\r\nvar utils = require('./utils');\r\nvar dc1 = require('./data-client')();\r\ndc1.codeName = \"dc1\";\r\nvar dc2 = require('./data-client')();\r\ndc2.codeName = \"dc2\";\r\nvar q1, q2;     // Quill instances\r\nvar cm1, cm2;   // Cursors modules\r\n\r\nvar quillParams = {\r\n  theme: 'snow',\r\n  placeholder: \"Let's write a story together.\",\r\n  modules: {\r\n    cursors: {\r\n      autoRegisterListener: false\r\n    },\r\n    history: {\r\n      userOnly: true\r\n    }\r\n  },\r\n  readOnly: true\r\n};\r\n\r\n$(document).ready(function () {\r\n  Quill.register('modules/cursors', QuillCursors);\r\n  q1 = new Quill('#editorL', quillParams);\r\n  q2 = new Quill('#editorR', quillParams);\r\n  $(\".editorWrap\").removeClass(\"hidden\");\r\n  wireupColors();\r\n  wireupConnectEvents([[dc1, $(\".half.left\")], [dc2, $(\".half.right\")]]);\r\n  wireupCursors();\r\n  wireupContent();\r\n});\r\n\r\nfunction wireupColors() {\r\n  function updateColor(elmTxt, elmBtn, dc) {\r\n    colors.forEach(x => elmBtn.removeClass(x));\r\n    var ix = Math.abs(utils.hash(elmTxt.val())) % 6;\r\n    elmBtn.addClass(colors[ix]);\r\n    dc.color = colors[ix];\r\n  }\r\n  var elmTxtL = $(\".half.left .connect input[type='text']\");\r\n  var elmBtnL = $(\".half.left .connect input[type='button']\");\r\n  updateColor(elmTxtL, elmBtnL, dc1);\r\n  elmTxtL.on(\"input\", function () {\r\n    updateColor(elmTxtL, elmBtnL, dc1);\r\n  });\r\n  var elmTxtR = $(\".half.right .connect input[type='text']\");\r\n  var elmBtnR = $(\".half.right .connect input[type='button']\");\r\n  updateColor(elmTxtR, elmBtnR, dc2);\r\n  elmTxtR.on(\"input\", function () {\r\n    updateColor(elmTxtR, elmBtnR, dc2);\r\n  });\r\n}\r\n\r\nfunction wireupContent() {\r\n  q1.on('text-change', function (delta, oldDelta, source) {\r\n    //console.log(\"[shuang] q1 text-change\");\r\n    //console.log(\"[shuang] delta:\", delta);\r\n    //console.log(\"[shuang] source:\", source);\r\n    dc1.contentChanged(delta, oldDelta, source);\r\n  });\r\n  q2.on('text-change', function (delta, oldDelta, source) {\r\n    //console.log(\"[shuang] q2 text-change\");\r\n    //console.log(\"[shuang] delta:\", delta);\r\n    //console.log(\"[shuang] source:\", source);\r\n    dc2.contentChanged(delta, oldDelta, source);\r\n  });\r\n\r\n  document.addEventListener('dataclient-content', function (e) {\r\n    var q;\r\n    if (e.detail.sender.codeName == \"dc1\") q = q1;\r\n    else if (e.detail.sender.codeName == \"dc2\") q = q2;\r\n    q.setContents(e.detail.data);\r\n  });\r\n  document.addEventListener('dataclient-delta', function (e) {\r\n    var q;\r\n    if (e.detail.sender.codeName == \"dc1\") q = q1;\r\n    else if (e.detail.sender.codeName == \"dc2\") q = q2;\r\n    q.updateContents(e.detail.data);\r\n  });\r\n}\r\n\r\nfunction wireupCursors() {\r\n  cm1 = q1.getModule(\"cursors\");\r\n  cm1.registerTextChangeListener();\r\n  cm2 = q2.getModule(\"cursors\");\r\n  cm2.registerTextChangeListener();\r\n\r\n  //var debouncedSendCursorData = utils.debounce(function () {\r\n  //  var r1 = q1.getSelection();\r\n  //  if (r1) {\r\n  //    console.log('[shuang] Stopped typing, sending a cursor update/refresh.');\r\n  //    sendCursorData(r1);\r\n  //  }\r\n  //  var r2 = q2.getSelection();\r\n  //  if (r2) {\r\n  //    console.log('[shuang] Stopped typing, sending a cursor update/refresh.');\r\n  //    sendCursorData(r2);\r\n  //  }\r\n  //}, 1500);\r\n  //doc.on('nothing pending', debouncedSendCursorData);\r\n\r\n  q1.on('selection-change', function (range, oldRange, source) {\r\n    dc1.selectionChanged(range);\r\n  });\r\n\r\n  q2.on('selection-change', function (range, oldRange, source) {\r\n    dc2.selectionChanged(range);\r\n  });\r\n\r\n  document.addEventListener('dataclient-cursor-update', function (e) {\r\n    if (e.detail.sender.codeName == \"dc1\")\r\n      updateCursors(e.detail.source, cm1, dc1);\r\n    else if (e.detail.sender.codeName == \"dc2\")\r\n      updateCursors(e.detail.source, cm2, dc2);\r\n  });\r\n}\r\n\r\n\r\nfunction updateCursors(source, cm, dc) {\r\n  var activePeers = {};\r\n  // If cursors module has no cursors yet, time to show them all.\r\n  // Otherwise, only update sender's cursor.\r\n  var updateAll = Object.keys(cm.cursors).length == 0;\r\n\r\n  dc.peers.forEach((peer) => {\r\n    if (peer.id == dc.me.id) return;\r\n    // Update cursor that sent the update, or update all if we're initializing\r\n    if ((peer.id == source.id || updateAll) && peer.range) {\r\n      cm.setCursor(peer.id, peer.range, peer.name, peer.color);\r\n    }\r\n    // Seen, hence active\r\n    activePeers[peer.id] = peer;\r\n  });\r\n\r\n  // Clear cursors if peer is gone\r\n  Object.keys(cm.cursors).forEach((id) => {\r\n    if (!activePeers[id]) {\r\n      cm.removeCursor(id);\r\n    }\r\n  });\r\n}\r\n\r\n\r\nfunction wireupConnectEvents(clients) {\r\n  clients.forEach((x) => {\r\n    var dc = x[0];\r\n    var elm = x[1];\r\n    var elmButton = elm.find(\".connect input[type='button']\");\r\n    var elmTxt = elm.find(\".connect input[type='text']\");\r\n    elmButton.click(function () {\r\n      if ($(this).hasClass(\"disabled\")) return;\r\n      if (dc.connected) dc.disconnect();\r\n      else {\r\n        var name = elmTxt.val();\r\n        var color = dc.codeName == \"dc1\" ? \"red\" : \"blue\";\r\n        dc.connect(name);\r\n      }\r\n      $(this).addClass(\"disabled\");\r\n      elmTxt.prop(\"readonly\", true);\r\n    });\r\n  });\r\n  document.addEventListener(\"dataclient-connected\", function (e, f) {\r\n    var elmBtn = null;\r\n    if (e.detail.sender.codeName == \"dc1\") {\r\n      elmBtn = $(\".half.left .connect input[type='button']\");\r\n      q1.enable();\r\n      updateCursors(dc1.me, cm1, dc1);\r\n    }\r\n    else {\r\n      elmBtn = $(\".half.right .connect input[type='button']\");\r\n      q2.enable();\r\n      updateCursors(dc2.me, cm2, dc2);\r\n    }\r\n    elmBtn.attr(\"value\", \"Disconnect\");\r\n    elmBtn.removeClass(\"disabled\");\r\n  });\r\n  document.addEventListener(\"dataclient-disconnected\", function (e) {\r\n    var elmBtn;\r\n    var elmTxt;\r\n    if (e.detail.sender.codeName == \"dc1\") {\r\n      elmBtn = $(\".half.left .connect input[type='button']\");\r\n      elmTxt = $(\".half.left .connect input[type='text']\");\r\n      q1.disable();\r\n    }\r\n    else {\r\n      elmBtn = $(\".half.right .connect input[type='button']\");\r\n      elmTxt = $(\".half.right .connect input[type='text']\");\r\n      q2.disable();\r\n    }\r\n    elmBtn.attr(\"value\", \"Connect\");\r\n    elmBtn.removeClass(\"disabled\");\r\n    elmTxt.prop(\"readonly\", false);\r\n  });\r\n  document.addEventListener(\"dataclient-peers\", function (e) {\r\n    var dc, cm;\r\n    if (e.detail.sender.codeName == \"dc1\") { dc = dc1; cm = cm1; }\r\n    else { dc = dc2; cm = cm2; }\r\n    updateCursors(e.detail.source, cm, dc);\r\n    var html = \"\";\r\n    console.log(e.detail.peers);\r\n    e.detail.peers.forEach((p) => {\r\n      html += \"<p class='\" + p.color + \"'>\";\r\n      html += utils.esc(p.name);\r\n      if (p.id == dc.me.id) html += \" (me)\";\r\n      html += \"</p>\";\r\n    });\r\n    $(\"#peerlist\").html(html);\r\n  });\r\n\r\n}\r\n\r\n","// Returns a function, that, as long as it continues to be invoked, will not\r\n// be triggered. The function will be called after it stops being called for\r\n// N milliseconds. If `immediate` is passed, trigger the function on the\r\n// leading edge, instead of the trailing.\r\nexports.debounce = function (func, wait, immediate) {\r\n  var timeout;\r\n  return function () {\r\n    var context = this,\r\n      args = arguments;\r\n    var later = function () {\r\n      timeout = null;\r\n      if (!immediate) func.apply(context, args);\r\n    };\r\n    var callNow = immediate && !timeout;\r\n    clearTimeout(timeout);\r\n    timeout = setTimeout(later, wait);\r\n    if (callNow) func.apply(context, args);\r\n  };\r\n};\r\n\r\nexports.hash = function (str) {\r\n  var hash = 0, i = 0, len = str.length;\r\n  while (i < len) {\r\n    hash = ((hash << 5) - hash + str.charCodeAt(i++)) << 0;\r\n  }\r\n  return hash;\r\n};\r\n\r\nexports.esc = function (s) {\r\n  return s.replace(/&/g, '&amp;')\r\n    .replace(/\"/g, '&quot;')\r\n    .replace(/</g, '&lt;')\r\n    .replace(/>/g, '&gt;');\r\n}\r\n"]}