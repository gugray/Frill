{"version":3,"sources":["node_modules/browser-pack/_prelude.js","node_modules/reconnectingwebsocket/reconnecting-websocket.js","app.js","src/js/data-client.js","src/js/main.js","src/js/utils.js"],"names":["e","t","n","r","s","o","u","a","require","i","f","Error","code","l","exports","call","length","1","module","global","factory","define","amd","ReconnectingWebSocket","this","url","protocols","options","generateEvent","args","evt","document","createEvent","initCustomEvent","settings","debug","automaticOpen","reconnectInterval","maxReconnectInterval","reconnectDecay","timeoutInterval","maxReconnectAttempts","key","reconnectAttempts","readyState","WebSocket","CONNECTING","protocol","ws","self","forcedClose","timedOut","eventTarget","createElement","addEventListener","event","onopen","onclose","onconnecting","onmessage","onerror","bind","removeEventListener","dispatchEvent","open","reconnectAttempt","debugAll","console","localWs","timeout","setTimeout","close","clearTimeout","OPEN","isReconnect","CLOSED","reason","wasClean","Math","pow","data","send","refresh","window","prototype","CLOSING","2","codeName","initSocketHandlers","DataClient","socket","connected","sendMyDetails","CustomEvent","detail","sender","message","msgObj","JSON","parse","msg","source","removedPeers","forceSendDetails","reportNewPeers","me","id","peers","receivedPeer","find","p","name","log","push","sourceId","onMsgPeers","peer","range","onMsgSelection","onMsgContent","onMsgDelta","connect","color","wsAddr","location","host","disconnect","stringify","selectionChanged","contentChanged","delta","oldDelta","index","reconnectingwebsocket","3","updateCursors","cm","dc","activePeers","updateAll","Object","keys","cursors","forEach","setCursor","removeCursor","dc1","dc2","q1","q2","cm1","cm2","quillParams","theme","modules","autoRegisterListener","history","userOnly","readOnly","$","ready","Quill","register","QuillCursors","removeClass","clients","x","elm","click","hasClass","val","addClass","elmBtn","enable","attr","disable","wireupConnectEvents","getModule","registerTextChangeListener","on","oldRange","q","setContents","updateContents","./data-client","./utils","4","debounce","func","wait","immediate","context","arguments","callNow","apply"],"mappings":"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","file":"app.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","// MIT License:\n//\n// Copyright (c) 2010-2012, Joe Walnes\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n/**\n * This behaves like a WebSocket in every way, except if it fails to connect,\n * or it gets disconnected, it will repeatedly poll until it successfully connects\n * again.\n *\n * It is API compatible, so when you have:\n *   ws = new WebSocket('ws://....');\n * you can replace with:\n *   ws = new ReconnectingWebSocket('ws://....');\n *\n * The event stream will typically look like:\n *  onconnecting\n *  onopen\n *  onmessage\n *  onmessage\n *  onclose // lost connection\n *  onconnecting\n *  onopen  // sometime later...\n *  onmessage\n *  onmessage\n *  etc...\n *\n * It is API compatible with the standard WebSocket API, apart from the following members:\n *\n * - `bufferedAmount`\n * - `extensions`\n * - `binaryType`\n *\n * Latest version: https://github.com/joewalnes/reconnecting-websocket/\n * - Joe Walnes\n *\n * Syntax\n * ======\n * var socket = new ReconnectingWebSocket(url, protocols, options);\n *\n * Parameters\n * ==========\n * url - The url you are connecting to.\n * protocols - Optional string or array of protocols.\n * options - See below\n *\n * Options\n * =======\n * Options can either be passed upon instantiation or set after instantiation:\n *\n * var socket = new ReconnectingWebSocket(url, null, { debug: true, reconnectInterval: 4000 });\n *\n * or\n *\n * var socket = new ReconnectingWebSocket(url);\n * socket.debug = true;\n * socket.reconnectInterval = 4000;\n *\n * debug\n * - Whether this instance should log debug messages. Accepts true or false. Default: false.\n *\n * automaticOpen\n * - Whether or not the websocket should attempt to connect immediately upon instantiation. The socket can be manually opened or closed at any time using ws.open() and ws.close().\n *\n * reconnectInterval\n * - The number of milliseconds to delay before attempting to reconnect. Accepts integer. Default: 1000.\n *\n * maxReconnectInterval\n * - The maximum number of milliseconds to delay a reconnection attempt. Accepts integer. Default: 30000.\n *\n * reconnectDecay\n * - The rate of increase of the reconnect delay. Allows reconnect attempts to back off when problems persist. Accepts integer or float. Default: 1.5.\n *\n * timeoutInterval\n * - The maximum time in milliseconds to wait for a connection to succeed before closing and retrying. Accepts integer. Default: 2000.\n *\n */\n(function (global, factory) {\n    if (typeof define === 'function' && define.amd) {\n        define([], factory);\n    } else if (typeof module !== 'undefined' && module.exports){\n        module.exports = factory();\n    } else {\n        global.ReconnectingWebSocket = factory();\n    }\n})(this, function () {\n\n    if (!('WebSocket' in window)) {\n        return;\n    }\n\n    function ReconnectingWebSocket(url, protocols, options) {\n\n        // Default settings\n        var settings = {\n\n            /** Whether this instance should log debug messages. */\n            debug: false,\n\n            /** Whether or not the websocket should attempt to connect immediately upon instantiation. */\n            automaticOpen: true,\n\n            /** The number of milliseconds to delay before attempting to reconnect. */\n            reconnectInterval: 1000,\n            /** The maximum number of milliseconds to delay a reconnection attempt. */\n            maxReconnectInterval: 30000,\n            /** The rate of increase of the reconnect delay. Allows reconnect attempts to back off when problems persist. */\n            reconnectDecay: 1.5,\n\n            /** The maximum time in milliseconds to wait for a connection to succeed before closing and retrying. */\n            timeoutInterval: 2000,\n\n            /** The maximum number of reconnection attempts to make. Unlimited if null. */\n            maxReconnectAttempts: null\n        }\n        if (!options) { options = {}; }\n\n        // Overwrite and define settings with options if they exist.\n        for (var key in settings) {\n            if (typeof options[key] !== 'undefined') {\n                this[key] = options[key];\n            } else {\n                this[key] = settings[key];\n            }\n        }\n\n        // These should be treated as read-only properties\n\n        /** The URL as resolved by the constructor. This is always an absolute URL. Read only. */\n        this.url = url;\n\n        /** The number of attempted reconnects since starting, or the last successful connection. Read only. */\n        this.reconnectAttempts = 0;\n\n        /**\n         * The current state of the connection.\n         * Can be one of: WebSocket.CONNECTING, WebSocket.OPEN, WebSocket.CLOSING, WebSocket.CLOSED\n         * Read only.\n         */\n        this.readyState = WebSocket.CONNECTING;\n\n        /**\n         * A string indicating the name of the sub-protocol the server selected; this will be one of\n         * the strings specified in the protocols parameter when creating the WebSocket object.\n         * Read only.\n         */\n        this.protocol = null;\n\n        // Private state variables\n\n        var self = this;\n        var ws;\n        var forcedClose = false;\n        var timedOut = false;\n        var eventTarget = document.createElement('div');\n\n        // Wire up \"on*\" properties as event handlers\n\n        eventTarget.addEventListener('open',       function(event) { self.onopen(event); });\n        eventTarget.addEventListener('close',      function(event) { self.onclose(event); });\n        eventTarget.addEventListener('connecting', function(event) { self.onconnecting(event); });\n        eventTarget.addEventListener('message',    function(event) { self.onmessage(event); });\n        eventTarget.addEventListener('error',      function(event) { self.onerror(event); });\n\n        // Expose the API required by EventTarget\n\n        this.addEventListener = eventTarget.addEventListener.bind(eventTarget);\n        this.removeEventListener = eventTarget.removeEventListener.bind(eventTarget);\n        this.dispatchEvent = eventTarget.dispatchEvent.bind(eventTarget);\n\n        /**\n         * This function generates an event that is compatible with standard\n         * compliant browsers and IE9 - IE11\n         *\n         * This will prevent the error:\n         * Object doesn't support this action\n         *\n         * http://stackoverflow.com/questions/19345392/why-arent-my-parameters-getting-passed-through-to-a-dispatched-event/19345563#19345563\n         * @param s String The name that the event should use\n         * @param args Object an optional object that the event will use\n         */\n        function generateEvent(s, args) {\n        \tvar evt = document.createEvent(\"CustomEvent\");\n        \tevt.initCustomEvent(s, false, false, args);\n        \treturn evt;\n        };\n\n        this.open = function (reconnectAttempt) {\n            ws = new WebSocket(self.url, protocols || []);\n\n            if (reconnectAttempt) {\n                if (this.maxReconnectAttempts && this.reconnectAttempts > this.maxReconnectAttempts) {\n                    return;\n                }\n            } else {\n                eventTarget.dispatchEvent(generateEvent('connecting'));\n                this.reconnectAttempts = 0;\n            }\n\n            if (self.debug || ReconnectingWebSocket.debugAll) {\n                console.debug('ReconnectingWebSocket', 'attempt-connect', self.url);\n            }\n\n            var localWs = ws;\n            var timeout = setTimeout(function() {\n                if (self.debug || ReconnectingWebSocket.debugAll) {\n                    console.debug('ReconnectingWebSocket', 'connection-timeout', self.url);\n                }\n                timedOut = true;\n                localWs.close();\n                timedOut = false;\n            }, self.timeoutInterval);\n\n            ws.onopen = function(event) {\n                clearTimeout(timeout);\n                if (self.debug || ReconnectingWebSocket.debugAll) {\n                    console.debug('ReconnectingWebSocket', 'onopen', self.url);\n                }\n                self.protocol = ws.protocol;\n                self.readyState = WebSocket.OPEN;\n                self.reconnectAttempts = 0;\n                var e = generateEvent('open');\n                e.isReconnect = reconnectAttempt;\n                reconnectAttempt = false;\n                eventTarget.dispatchEvent(e);\n            };\n\n            ws.onclose = function(event) {\n                clearTimeout(timeout);\n                ws = null;\n                if (forcedClose) {\n                    self.readyState = WebSocket.CLOSED;\n                    eventTarget.dispatchEvent(generateEvent('close'));\n                } else {\n                    self.readyState = WebSocket.CONNECTING;\n                    var e = generateEvent('connecting');\n                    e.code = event.code;\n                    e.reason = event.reason;\n                    e.wasClean = event.wasClean;\n                    eventTarget.dispatchEvent(e);\n                    if (!reconnectAttempt && !timedOut) {\n                        if (self.debug || ReconnectingWebSocket.debugAll) {\n                            console.debug('ReconnectingWebSocket', 'onclose', self.url);\n                        }\n                        eventTarget.dispatchEvent(generateEvent('close'));\n                    }\n\n                    var timeout = self.reconnectInterval * Math.pow(self.reconnectDecay, self.reconnectAttempts);\n                    setTimeout(function() {\n                        self.reconnectAttempts++;\n                        self.open(true);\n                    }, timeout > self.maxReconnectInterval ? self.maxReconnectInterval : timeout);\n                }\n            };\n            ws.onmessage = function(event) {\n                if (self.debug || ReconnectingWebSocket.debugAll) {\n                    console.debug('ReconnectingWebSocket', 'onmessage', self.url, event.data);\n                }\n                var e = generateEvent('message');\n                e.data = event.data;\n                eventTarget.dispatchEvent(e);\n            };\n            ws.onerror = function(event) {\n                if (self.debug || ReconnectingWebSocket.debugAll) {\n                    console.debug('ReconnectingWebSocket', 'onerror', self.url, event);\n                }\n                eventTarget.dispatchEvent(generateEvent('error'));\n            };\n        }\n\n        // Whether or not to create a websocket upon instantiation\n        if (this.automaticOpen == true) {\n            this.open(false);\n        }\n\n        /**\n         * Transmits data to the server over the WebSocket connection.\n         *\n         * @param data a text string, ArrayBuffer or Blob to send to the server.\n         */\n        this.send = function(data) {\n            if (ws) {\n                if (self.debug || ReconnectingWebSocket.debugAll) {\n                    console.debug('ReconnectingWebSocket', 'send', self.url, data);\n                }\n                return ws.send(data);\n            } else {\n                throw 'INVALID_STATE_ERR : Pausing to reconnect websocket';\n            }\n        };\n\n        /**\n         * Closes the WebSocket connection or connection attempt, if any.\n         * If the connection is already CLOSED, this method does nothing.\n         */\n        this.close = function(code, reason) {\n            // Default CLOSE_NORMAL code\n            if (typeof code == 'undefined') {\n                code = 1000;\n            }\n            forcedClose = true;\n            if (ws) {\n                ws.close(code, reason);\n            }\n        };\n\n        /**\n         * Additional public API method to refresh the connection if still open (close, re-open).\n         * For example, if the app suspects bad data / missed heart beats, it can try to refresh.\n         */\n        this.refresh = function() {\n            if (ws) {\n                ws.close();\n            }\n        };\n    }\n\n    /**\n     * An event listener to be called when the WebSocket connection's readyState changes to OPEN;\n     * this indicates that the connection is ready to send and receive data.\n     */\n    ReconnectingWebSocket.prototype.onopen = function(event) {};\n    /** An event listener to be called when the WebSocket connection's readyState changes to CLOSED. */\n    ReconnectingWebSocket.prototype.onclose = function(event) {};\n    /** An event listener to be called when a connection begins being attempted. */\n    ReconnectingWebSocket.prototype.onconnecting = function(event) {};\n    /** An event listener to be called when a message is received from the server. */\n    ReconnectingWebSocket.prototype.onmessage = function(event) {};\n    /** An event listener to be called when an error occurs. */\n    ReconnectingWebSocket.prototype.onerror = function(event) {};\n\n    /**\n     * Whether all instances of ReconnectingWebSocket should log debug messages.\n     * Setting this to true is the equivalent of setting all instances of ReconnectingWebSocket.debug to true.\n     */\n    ReconnectingWebSocket.debugAll = false;\n\n    ReconnectingWebSocket.CONNECTING = WebSocket.CONNECTING;\n    ReconnectingWebSocket.OPEN = WebSocket.OPEN;\n    ReconnectingWebSocket.CLOSING = WebSocket.CLOSING;\n    ReconnectingWebSocket.CLOSED = WebSocket.CLOSED;\n\n    return ReconnectingWebSocket;\n});\n","(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n// MIT License:\n//\n// Copyright (c) 2010-2012, Joe Walnes\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n/**\n * This behaves like a WebSocket in every way, except if it fails to connect,\n * or it gets disconnected, it will repeatedly poll until it successfully connects\n * again.\n *\n * It is API compatible, so when you have:\n *   ws = new WebSocket('ws://....');\n * you can replace with:\n *   ws = new ReconnectingWebSocket('ws://....');\n *\n * The event stream will typically look like:\n *  onconnecting\n *  onopen\n *  onmessage\n *  onmessage\n *  onclose // lost connection\n *  onconnecting\n *  onopen  // sometime later...\n *  onmessage\n *  onmessage\n *  etc...\n *\n * It is API compatible with the standard WebSocket API, apart from the following members:\n *\n * - `bufferedAmount`\n * - `extensions`\n * - `binaryType`\n *\n * Latest version: https://github.com/joewalnes/reconnecting-websocket/\n * - Joe Walnes\n *\n * Syntax\n * ======\n * var socket = new ReconnectingWebSocket(url, protocols, options);\n *\n * Parameters\n * ==========\n * url - The url you are connecting to.\n * protocols - Optional string or array of protocols.\n * options - See below\n *\n * Options\n * =======\n * Options can either be passed upon instantiation or set after instantiation:\n *\n * var socket = new ReconnectingWebSocket(url, null, { debug: true, reconnectInterval: 4000 });\n *\n * or\n *\n * var socket = new ReconnectingWebSocket(url);\n * socket.debug = true;\n * socket.reconnectInterval = 4000;\n *\n * debug\n * - Whether this instance should log debug messages. Accepts true or false. Default: false.\n *\n * automaticOpen\n * - Whether or not the websocket should attempt to connect immediately upon instantiation. The socket can be manually opened or closed at any time using ws.open() and ws.close().\n *\n * reconnectInterval\n * - The number of milliseconds to delay before attempting to reconnect. Accepts integer. Default: 1000.\n *\n * maxReconnectInterval\n * - The maximum number of milliseconds to delay a reconnection attempt. Accepts integer. Default: 30000.\n *\n * reconnectDecay\n * - The rate of increase of the reconnect delay. Allows reconnect attempts to back off when problems persist. Accepts integer or float. Default: 1.5.\n *\n * timeoutInterval\n * - The maximum time in milliseconds to wait for a connection to succeed before closing and retrying. Accepts integer. Default: 2000.\n *\n */\n(function (global, factory) {\n    if (typeof define === 'function' && define.amd) {\n        define([], factory);\n    } else if (typeof module !== 'undefined' && module.exports){\n        module.exports = factory();\n    } else {\n        global.ReconnectingWebSocket = factory();\n    }\n})(this, function () {\n\n    if (!('WebSocket' in window)) {\n        return;\n    }\n\n    function ReconnectingWebSocket(url, protocols, options) {\n\n        // Default settings\n        var settings = {\n\n            /** Whether this instance should log debug messages. */\n            debug: false,\n\n            /** Whether or not the websocket should attempt to connect immediately upon instantiation. */\n            automaticOpen: true,\n\n            /** The number of milliseconds to delay before attempting to reconnect. */\n            reconnectInterval: 1000,\n            /** The maximum number of milliseconds to delay a reconnection attempt. */\n            maxReconnectInterval: 30000,\n            /** The rate of increase of the reconnect delay. Allows reconnect attempts to back off when problems persist. */\n            reconnectDecay: 1.5,\n\n            /** The maximum time in milliseconds to wait for a connection to succeed before closing and retrying. */\n            timeoutInterval: 2000,\n\n            /** The maximum number of reconnection attempts to make. Unlimited if null. */\n            maxReconnectAttempts: null\n        }\n        if (!options) { options = {}; }\n\n        // Overwrite and define settings with options if they exist.\n        for (var key in settings) {\n            if (typeof options[key] !== 'undefined') {\n                this[key] = options[key];\n            } else {\n                this[key] = settings[key];\n            }\n        }\n\n        // These should be treated as read-only properties\n\n        /** The URL as resolved by the constructor. This is always an absolute URL. Read only. */\n        this.url = url;\n\n        /** The number of attempted reconnects since starting, or the last successful connection. Read only. */\n        this.reconnectAttempts = 0;\n\n        /**\n         * The current state of the connection.\n         * Can be one of: WebSocket.CONNECTING, WebSocket.OPEN, WebSocket.CLOSING, WebSocket.CLOSED\n         * Read only.\n         */\n        this.readyState = WebSocket.CONNECTING;\n\n        /**\n         * A string indicating the name of the sub-protocol the server selected; this will be one of\n         * the strings specified in the protocols parameter when creating the WebSocket object.\n         * Read only.\n         */\n        this.protocol = null;\n\n        // Private state variables\n\n        var self = this;\n        var ws;\n        var forcedClose = false;\n        var timedOut = false;\n        var eventTarget = document.createElement('div');\n\n        // Wire up \"on*\" properties as event handlers\n\n        eventTarget.addEventListener('open',       function(event) { self.onopen(event); });\n        eventTarget.addEventListener('close',      function(event) { self.onclose(event); });\n        eventTarget.addEventListener('connecting', function(event) { self.onconnecting(event); });\n        eventTarget.addEventListener('message',    function(event) { self.onmessage(event); });\n        eventTarget.addEventListener('error',      function(event) { self.onerror(event); });\n\n        // Expose the API required by EventTarget\n\n        this.addEventListener = eventTarget.addEventListener.bind(eventTarget);\n        this.removeEventListener = eventTarget.removeEventListener.bind(eventTarget);\n        this.dispatchEvent = eventTarget.dispatchEvent.bind(eventTarget);\n\n        /**\n         * This function generates an event that is compatible with standard\n         * compliant browsers and IE9 - IE11\n         *\n         * This will prevent the error:\n         * Object doesn't support this action\n         *\n         * http://stackoverflow.com/questions/19345392/why-arent-my-parameters-getting-passed-through-to-a-dispatched-event/19345563#19345563\n         * @param s String The name that the event should use\n         * @param args Object an optional object that the event will use\n         */\n        function generateEvent(s, args) {\n        \tvar evt = document.createEvent(\"CustomEvent\");\n        \tevt.initCustomEvent(s, false, false, args);\n        \treturn evt;\n        };\n\n        this.open = function (reconnectAttempt) {\n            ws = new WebSocket(self.url, protocols || []);\n\n            if (reconnectAttempt) {\n                if (this.maxReconnectAttempts && this.reconnectAttempts > this.maxReconnectAttempts) {\n                    return;\n                }\n            } else {\n                eventTarget.dispatchEvent(generateEvent('connecting'));\n                this.reconnectAttempts = 0;\n            }\n\n            if (self.debug || ReconnectingWebSocket.debugAll) {\n                console.debug('ReconnectingWebSocket', 'attempt-connect', self.url);\n            }\n\n            var localWs = ws;\n            var timeout = setTimeout(function() {\n                if (self.debug || ReconnectingWebSocket.debugAll) {\n                    console.debug('ReconnectingWebSocket', 'connection-timeout', self.url);\n                }\n                timedOut = true;\n                localWs.close();\n                timedOut = false;\n            }, self.timeoutInterval);\n\n            ws.onopen = function(event) {\n                clearTimeout(timeout);\n                if (self.debug || ReconnectingWebSocket.debugAll) {\n                    console.debug('ReconnectingWebSocket', 'onopen', self.url);\n                }\n                self.protocol = ws.protocol;\n                self.readyState = WebSocket.OPEN;\n                self.reconnectAttempts = 0;\n                var e = generateEvent('open');\n                e.isReconnect = reconnectAttempt;\n                reconnectAttempt = false;\n                eventTarget.dispatchEvent(e);\n            };\n\n            ws.onclose = function(event) {\n                clearTimeout(timeout);\n                ws = null;\n                if (forcedClose) {\n                    self.readyState = WebSocket.CLOSED;\n                    eventTarget.dispatchEvent(generateEvent('close'));\n                } else {\n                    self.readyState = WebSocket.CONNECTING;\n                    var e = generateEvent('connecting');\n                    e.code = event.code;\n                    e.reason = event.reason;\n                    e.wasClean = event.wasClean;\n                    eventTarget.dispatchEvent(e);\n                    if (!reconnectAttempt && !timedOut) {\n                        if (self.debug || ReconnectingWebSocket.debugAll) {\n                            console.debug('ReconnectingWebSocket', 'onclose', self.url);\n                        }\n                        eventTarget.dispatchEvent(generateEvent('close'));\n                    }\n\n                    var timeout = self.reconnectInterval * Math.pow(self.reconnectDecay, self.reconnectAttempts);\n                    setTimeout(function() {\n                        self.reconnectAttempts++;\n                        self.open(true);\n                    }, timeout > self.maxReconnectInterval ? self.maxReconnectInterval : timeout);\n                }\n            };\n            ws.onmessage = function(event) {\n                if (self.debug || ReconnectingWebSocket.debugAll) {\n                    console.debug('ReconnectingWebSocket', 'onmessage', self.url, event.data);\n                }\n                var e = generateEvent('message');\n                e.data = event.data;\n                eventTarget.dispatchEvent(e);\n            };\n            ws.onerror = function(event) {\n                if (self.debug || ReconnectingWebSocket.debugAll) {\n                    console.debug('ReconnectingWebSocket', 'onerror', self.url, event);\n                }\n                eventTarget.dispatchEvent(generateEvent('error'));\n            };\n        }\n\n        // Whether or not to create a websocket upon instantiation\n        if (this.automaticOpen == true) {\n            this.open(false);\n        }\n\n        /**\n         * Transmits data to the server over the WebSocket connection.\n         *\n         * @param data a text string, ArrayBuffer or Blob to send to the server.\n         */\n        this.send = function(data) {\n            if (ws) {\n                if (self.debug || ReconnectingWebSocket.debugAll) {\n                    console.debug('ReconnectingWebSocket', 'send', self.url, data);\n                }\n                return ws.send(data);\n            } else {\n                throw 'INVALID_STATE_ERR : Pausing to reconnect websocket';\n            }\n        };\n\n        /**\n         * Closes the WebSocket connection or connection attempt, if any.\n         * If the connection is already CLOSED, this method does nothing.\n         */\n        this.close = function(code, reason) {\n            // Default CLOSE_NORMAL code\n            if (typeof code == 'undefined') {\n                code = 1000;\n            }\n            forcedClose = true;\n            if (ws) {\n                ws.close(code, reason);\n            }\n        };\n\n        /**\n         * Additional public API method to refresh the connection if still open (close, re-open).\n         * For example, if the app suspects bad data / missed heart beats, it can try to refresh.\n         */\n        this.refresh = function() {\n            if (ws) {\n                ws.close();\n            }\n        };\n    }\n\n    /**\n     * An event listener to be called when the WebSocket connection's readyState changes to OPEN;\n     * this indicates that the connection is ready to send and receive data.\n     */\n    ReconnectingWebSocket.prototype.onopen = function(event) {};\n    /** An event listener to be called when the WebSocket connection's readyState changes to CLOSED. */\n    ReconnectingWebSocket.prototype.onclose = function(event) {};\n    /** An event listener to be called when a connection begins being attempted. */\n    ReconnectingWebSocket.prototype.onconnecting = function(event) {};\n    /** An event listener to be called when a message is received from the server. */\n    ReconnectingWebSocket.prototype.onmessage = function(event) {};\n    /** An event listener to be called when an error occurs. */\n    ReconnectingWebSocket.prototype.onerror = function(event) {};\n\n    /**\n     * Whether all instances of ReconnectingWebSocket should log debug messages.\n     * Setting this to true is the equivalent of setting all instances of ReconnectingWebSocket.debug to true.\n     */\n    ReconnectingWebSocket.debugAll = false;\n\n    ReconnectingWebSocket.CONNECTING = WebSocket.CONNECTING;\n    ReconnectingWebSocket.OPEN = WebSocket.OPEN;\n    ReconnectingWebSocket.CLOSING = WebSocket.CLOSING;\n    ReconnectingWebSocket.CLOSED = WebSocket.CLOSED;\n\n    return ReconnectingWebSocket;\n});\n\n},{}],2:[function(require,module,exports){\n\"use strict\";\r\n\r\nvar ReconnectingWebSocket = require('reconnectingwebsocket');\r\n\r\nmodule.exports = function (codeName) {\r\n  var DataClient = {};\r\n\r\n  function Peer(name, color) {\r\n    this.id = null;\r\n    this.name = name;\r\n    this.color = color;\r\n  }\r\n\r\n  // Consumer should set this to unique names in page if there are multiple clients\r\n  DataClient.codeName = \"dc\";\r\n\r\n  DataClient.me = null;\r\n  DataClient.connected = false;\r\n\r\n  // Peers that are around\r\n  DataClient.peers = [];\r\n\r\n  DataClient.connect = function (name, color) {\r\n    DataClient.me = new Peer(name, color);\r\n    // Create browserchannel socket\r\n    var wsAddr = ((location.protocol === 'https:') ? 'wss' : 'ws') + '://' + window.location.host + '/data';\r\n    //DataClient.socket = new ReconnectingWebSocket(wsAddr);\r\n    DataClient.socket = new WebSocket(wsAddr);\r\n    initSocketHandlers();\r\n  }\r\n\r\n  DataClient.disconnect = function () {\r\n    DataClient.socket.close();\r\n    delete DataClient.socket;\r\n    delete DataClient.me;\r\n    DataClient.peers = [];\r\n  }\r\n\r\n  // Send my details\r\n  DataClient.sendMyDetails = function () {\r\n    var msgObj = {\r\n      msg: \"details\",\r\n      data: DataClient.me\r\n    };\r\n    DataClient.socket.send(JSON.stringify(msgObj));\r\n  };\r\n\r\n  // Store and send new selection\r\n  DataClient.selectionChanged = function (range) {\r\n    DataClient.me.range = range;\r\n    var msgObj = {\r\n      msg: \"selection\",\r\n      data: DataClient.me.range\r\n    };\r\n    DataClient.socket.send(JSON.stringify(msgObj));\r\n  }\r\n\r\n  // Local editor content changed (user input)\r\n  DataClient.contentChanged = function (delta, oldDelta, source) {\r\n    if (source != \"user\") return;\r\n\r\n    if (DataClient.me.range && DataClient.me.range.length) {\r\n      DataClient.me.range.index += DataClient.me.range.length;\r\n      DataClient.me.range.length = 0;\r\n      DataClient.selectionChanged();\r\n    }\r\n    var msgObj = {\r\n      msg: \"delta\",\r\n      data: delta\r\n    };\r\n    DataClient.socket.send(JSON.stringify(msgObj));\r\n  }\r\n\r\n  // Server sent selection update for one peer\r\n  function onMsgSelection(data) {\r\n    console.log(\"[DataClient] Peer selection received.\", data);\r\n    var peer = DataClient.peers.find((p) => { return p.id == data.id; });\r\n    if (!peer) return;\r\n    peer.range = data.range;\r\n    document.dispatchEvent(new CustomEvent('dataclient-cursor-update', {\r\n      detail: {\r\n        sender: DataClient,\r\n        source: peer\r\n      }\r\n    }));\r\n  }\r\n\r\n  // Server sent peer list\r\n  function onMsgPeers(data) {\r\n    var source = {};\r\n    var removedPeers = [];\r\n    var forceSendDetails = false;\r\n    var reportNewPeers = true;\r\n\r\n    if (!DataClient.me.id) forceSendDetails = true;\r\n    // Refresh local connection ID (we get it assigned from server)\r\n    DataClient.me.id = data.id;\r\n\r\n    if (forceSendDetails) {\r\n      DataClient.sendMyDetails();\r\n      return;\r\n    }\r\n\r\n    // Find removed peers\r\n    for (var i = 0; i < DataClient.peers.length; i++) {\r\n      var receivedPeer = data.peers.find((p) => { return p.id == DataClient.peers[i].id; });\r\n\r\n      if (!receivedPeer) {\r\n        removedPeers.push(DataClient.peers[i]);\r\n        console.log('[DataClient] Peer disconnected:', DataClient.peers[i]);\r\n\r\n        // If the source connection was removed set it\r\n        if (data.sourceId == DataClient.peers[i])\r\n          source = DataClient.peers[i];\r\n      } else if (receivedPeer.name && !DataClient.peers[i].name) {\r\n        console.log('[DataClient] User ' + receivedPeer.id + ' set username:', receivedPeer.name);\r\n        console.log('[DataClient] Peers after username update:', data.peers);\r\n      }\r\n    }\r\n\r\n    if (DataClient.peers.length == 0 && data.peers.length != 0) {\r\n      console.log('[DataClient] Initial list of peers received from server:', data.peers);\r\n      reportNewPeers = false;\r\n    }\r\n\r\n    for (var i = 0; i < data.peers.length; i++) {\r\n      // Set the source if it's still an active peers\r\n      if (data.sourceId == data.peers[i].id)\r\n        source = data.peers[i];\r\n\r\n      if (reportNewPeers && !DataClient.peers.find((p) => { return p.id == data.peers[i].id })) {\r\n        console.log('[DataClient] Peer connected:', data.peers[i]);\r\n        console.log('[DataClient] Peers after new user:', data.peers);\r\n      }\r\n    }\r\n\r\n    // Update peers array\r\n    DataClient.peers = data.peers;\r\n\r\n    // Tell consumer\r\n    document.dispatchEvent(new CustomEvent('dataclient-peers', {\r\n      detail: {\r\n        sender: DataClient,\r\n        source: source,\r\n        removedPeers: removedPeers\r\n      }\r\n    }));\r\n  }\r\n\r\n  function onMsgContent(data) {\r\n    console.log('[DataClient] Received document content.');\r\n    document.dispatchEvent(new CustomEvent('dataclient-content', {\r\n      detail: {\r\n        sender: DataClient,\r\n        data: data\r\n      }\r\n    }));\r\n  }\r\n\r\n  function onMsgDelta(data) {\r\n    console.log('[DataClient] Received document delta.');\r\n    document.dispatchEvent(new CustomEvent('dataclient-delta', {\r\n      detail: {\r\n        sender: DataClient,\r\n        data: data\r\n      }\r\n    }));\r\n  }\r\n\r\n  function initSocketHandlers() {\r\n\r\n    // Send initial message to register the client, and\r\n    // retrieve a list of current clients so we can set a colour.\r\n    DataClient.socket.onopen = function () {\r\n      DataClient.connected = true;\r\n      DataClient.sendMyDetails();\r\n      document.dispatchEvent(new CustomEvent('dataclient-connected', {\r\n        detail: {\r\n          sender: DataClient\r\n        }\r\n      }));\r\n    };\r\n\r\n    DataClient.socket.onmessage = function (message) {\r\n      var msgObj = JSON.parse(message.data);\r\n      if (msgObj.msg == \"peers\") onMsgPeers(msgObj.data);\r\n      else if (msgObj.msg == \"selection\") onMsgSelection(msgObj.data);\r\n      else if (msgObj.msg == \"content\") onMsgContent(msgObj.data);\r\n      else if (msgObj.msg == \"delta\") onMsgDelta(msgObj.data);\r\n    };\r\n\r\n    DataClient.socket.onclose = function (event) {\r\n      console.log('[DataClient] Socket closed. Event:', event);\r\n      DataClient.connected = false;\r\n      document.dispatchEvent(new CustomEvent('dataclient-disconnected', {\r\n        detail: {\r\n          sender: DataClient\r\n        }\r\n      }));\r\n    };\r\n\r\n    DataClient.socket.onerror = function (event) {\r\n      console.log('[DataClient] Error on socket. Event:', event);\r\n    };\r\n  }\r\n\r\n  return DataClient;\r\n}\r\n\r\n\n},{\"reconnectingwebsocket\":1}],3:[function(require,module,exports){\n\"use strict\";\r\n\r\nvar utils = require('./utils');\r\nvar dc1 = require('./data-client')();\r\ndc1.codeName = \"dc1\";\r\nvar dc2 = require('./data-client')();\r\ndc2.codeName = \"dc2\";\r\nvar q1, q2;     // Quill instances\r\nvar cm1, cm2;   // Cursors modules\r\n\r\nvar quillParams = {\r\n  theme: 'snow',\r\n  modules: {\r\n    cursors: {\r\n      autoRegisterListener: false\r\n    },\r\n    history: {\r\n      userOnly: true\r\n    }\r\n  },\r\n  readOnly: true\r\n};\r\n\r\n$(document).ready(function () {\r\n  Quill.register('modules/cursors', QuillCursors);\r\n  q1 = new Quill('#editorL', quillParams);\r\n  q2 = new Quill('#editorR', quillParams);\r\n  $(\".editorWrap\").removeClass(\"hidden\");\r\n  wireupConnectEvents([[dc1, $(\".half.left\")], [dc2, $(\".half.right\")]]);\r\n  wireupCursors();\r\n  wireupContent();\r\n});\r\n\r\nfunction wireupContent() {\r\n  q1.on('text-change', function (delta, oldDelta, source) {\r\n    //console.log(\"[shuang] q1 text-change\");\r\n    //console.log(\"[shuang] delta:\", delta);\r\n    //console.log(\"[shuang] source:\", source);\r\n    dc1.contentChanged(delta, oldDelta, source);\r\n  });\r\n  q2.on('text-change', function (delta, oldDelta, source) {\r\n    //console.log(\"[shuang] q2 text-change\");\r\n    //console.log(\"[shuang] delta:\", delta);\r\n    //console.log(\"[shuang] source:\", source);\r\n    dc2.contentChanged(delta, oldDelta, source);\r\n  });\r\n\r\n  document.addEventListener('dataclient-content', function (e) {\r\n    var q;\r\n    if (e.detail.sender.codeName == \"dc1\") q = q1;\r\n    else if (e.detail.sender.codeName == \"dc2\") q = q2;\r\n    q.setContents(e.detail.data);\r\n  });\r\n  document.addEventListener('dataclient-delta', function (e) {\r\n    var q;\r\n    if (e.detail.sender.codeName == \"dc1\") q = q1;\r\n    else if (e.detail.sender.codeName == \"dc2\") q = q2;\r\n    q.updateContents(e.detail.data);\r\n  });\r\n}\r\n\r\nfunction wireupCursors() {\r\n  cm1 = q1.getModule(\"cursors\");\r\n  cm1.registerTextChangeListener();\r\n  cm2 = q2.getModule(\"cursors\");\r\n  cm2.registerTextChangeListener();\r\n\r\n  //var debouncedSendCursorData = utils.debounce(function () {\r\n  //  var r1 = q1.getSelection();\r\n  //  if (r1) {\r\n  //    console.log('[shuang] Stopped typing, sending a cursor update/refresh.');\r\n  //    sendCursorData(r1);\r\n  //  }\r\n  //  var r2 = q2.getSelection();\r\n  //  if (r2) {\r\n  //    console.log('[shuang] Stopped typing, sending a cursor update/refresh.');\r\n  //    sendCursorData(r2);\r\n  //  }\r\n  //}, 1500);\r\n  //doc.on('nothing pending', debouncedSendCursorData);\r\n\r\n  q1.on('selection-change', function (range, oldRange, source) {\r\n    dc1.selectionChanged(range);\r\n  });\r\n\r\n  q2.on('selection-change', function (range, oldRange, source) {\r\n    dc2.selectionChanged(range);\r\n  });\r\n\r\n  document.addEventListener('dataclient-cursor-update', function (e) {\r\n    if (e.detail.sender.codeName == \"dc1\")\r\n      updateCursors(e.detail.source, cm1, dc1);\r\n    else if (e.detail.sender.codeName == \"dc2\")\r\n      updateCursors(e.detail.source, cm2, dc2);\r\n  });\r\n}\r\n\r\n\r\nfunction updateCursors(source, cm, dc) {\r\n  var activePeers = {};\r\n  // If cursors module has no cursors yet, time to show them all.\r\n  // Otherwise, only update sender's cursor.\r\n  var updateAll = Object.keys(cm.cursors).length == 0;\r\n\r\n  dc.peers.forEach((peer) => {\r\n    if (peer.id == dc.me.id) return;\r\n    // Update cursor that sent the update, or update all if we're initializing\r\n    if ((peer.id == source.id || updateAll) && peer.range) {\r\n      cm.setCursor(peer.id, peer.range, peer.name, peer.color);\r\n    }\r\n    // Seen, hence active\r\n    activePeers[peer.id] = peer;\r\n  });\r\n\r\n  // Clear cursors if peer is gone\r\n  Object.keys(cm.cursors).forEach((id) => {\r\n    if (!activePeers[id]) {\r\n      cm.removeCursor(id);\r\n    }\r\n  });\r\n}\r\n\r\n\r\nfunction wireupConnectEvents(clients) {\r\n  clients.forEach((x) => {\r\n    var dc = x[0];\r\n    var elm = x[1];\r\n    var elmButton = elm.find(\".connect input[type='button']\");\r\n    elmButton.click(function () {\r\n      if ($(this).hasClass(\"disabled\")) return;\r\n      if (dc.connected) dc.disconnect();\r\n      else {\r\n        var name = elm.find(\".connect input[type='text']\").val();\r\n        var color = dc.codeName == \"dc1\" ? \"red\" : \"blue\";\r\n        dc.connect(name, color);\r\n      }\r\n      $(this).addClass(\"disabled\");\r\n    });\r\n  });\r\n  document.addEventListener(\"dataclient-connected\", function (e, f) {\r\n    var elmBtn = null;\r\n    if (e.detail.sender.codeName == \"dc1\") {\r\n      elmBtn = $(\".half.left .connect input[type='button']\");\r\n      q1.enable();\r\n      updateCursors(dc1.me, cm1, dc1);\r\n    }\r\n    else {\r\n      elmBtn = $(\".half.right .connect input[type='button']\");\r\n      q2.enable();\r\n      updateCursors(dc2.me, cm2, dc2);\r\n    }\r\n    elmBtn.attr(\"value\", \"Disconnect\");\r\n    elmBtn.removeClass(\"disabled\");\r\n  });\r\n  document.addEventListener(\"dataclient-disconnected\", function (e) {\r\n    var elmBtn;\r\n    if (e.detail.sender.codeName == \"dc1\") {\r\n      elmBtn = $(\".half.left .connect input[type='button']\");\r\n      q1.disable();\r\n    }\r\n    else {\r\n      elmBtn = $(\".half.right .connect input[type='button']\");\r\n      q2.disable();\r\n    }\r\n    elmBtn.attr(\"value\", \"Connect\");\r\n    elmBtn.removeClass(\"disabled\");\r\n  });\r\n  document.addEventListener(\"dataclient-peers\", function (e) {\r\n    if (e.detail.sender.codeName == \"dc1\")\r\n      updateCursors(e.detail.source, cm1, dc1);\r\n    else if (e.detail.sender.codeName == \"dc2\")\r\n      updateCursors(e.detail.source, cm2, dc2);\r\n  });\r\n\r\n}\r\n\r\n\n},{\"./data-client\":2,\"./utils\":4}],4:[function(require,module,exports){\n// Returns a function, that, as long as it continues to be invoked, will not\r\n// be triggered. The function will be called after it stops being called for\r\n// N milliseconds. If `immediate` is passed, trigger the function on the\r\n// leading edge, instead of the trailing.\r\nexports.debounce = function (func, wait, immediate) {\r\n  var timeout;\r\n  return function () {\r\n    var context = this,\r\n      args = arguments;\r\n    var later = function () {\r\n      timeout = null;\r\n      if (!immediate) func.apply(context, args);\r\n    };\r\n    var callNow = immediate && !timeout;\r\n    clearTimeout(timeout);\r\n    timeout = setTimeout(later, wait);\r\n    if (callNow) func.apply(context, args);\r\n  };\r\n};\r\n\n},{}]},{},[3])\n\n","\"use strict\";\r\n\r\nvar ReconnectingWebSocket = require('reconnectingwebsocket');\r\n\r\nmodule.exports = function (codeName) {\r\n  var DataClient = {};\r\n\r\n  function Peer(name, color) {\r\n    this.id = null;\r\n    this.name = name;\r\n    this.color = color;\r\n  }\r\n\r\n  // Consumer should set this to unique names in page if there are multiple clients\r\n  DataClient.codeName = \"dc\";\r\n\r\n  DataClient.me = null;\r\n  DataClient.connected = false;\r\n\r\n  // Peers that are around\r\n  DataClient.peers = [];\r\n\r\n  DataClient.connect = function (name, color) {\r\n    DataClient.me = new Peer(name, color);\r\n    // Create browserchannel socket\r\n    var wsAddr = ((location.protocol === 'https:') ? 'wss' : 'ws') + '://' + window.location.host + '/data';\r\n    //DataClient.socket = new ReconnectingWebSocket(wsAddr);\r\n    DataClient.socket = new WebSocket(wsAddr);\r\n    initSocketHandlers();\r\n  }\r\n\r\n  DataClient.disconnect = function () {\r\n    DataClient.socket.close();\r\n    delete DataClient.socket;\r\n    delete DataClient.me;\r\n    DataClient.peers = [];\r\n  }\r\n\r\n  // Send my details\r\n  DataClient.sendMyDetails = function () {\r\n    var msgObj = {\r\n      msg: \"details\",\r\n      data: DataClient.me\r\n    };\r\n    DataClient.socket.send(JSON.stringify(msgObj));\r\n  };\r\n\r\n  // Store and send new selection\r\n  DataClient.selectionChanged = function (range) {\r\n    DataClient.me.range = range;\r\n    var msgObj = {\r\n      msg: \"selection\",\r\n      data: DataClient.me.range\r\n    };\r\n    DataClient.socket.send(JSON.stringify(msgObj));\r\n  }\r\n\r\n  // Local editor content changed (user input)\r\n  DataClient.contentChanged = function (delta, oldDelta, source) {\r\n    if (source != \"user\") return;\r\n\r\n    if (DataClient.me.range && DataClient.me.range.length) {\r\n      DataClient.me.range.index += DataClient.me.range.length;\r\n      DataClient.me.range.length = 0;\r\n      DataClient.selectionChanged();\r\n    }\r\n    var msgObj = {\r\n      msg: \"delta\",\r\n      data: delta\r\n    };\r\n    DataClient.socket.send(JSON.stringify(msgObj));\r\n  }\r\n\r\n  // Server sent selection update for one peer\r\n  function onMsgSelection(data) {\r\n    console.log(\"[DataClient] Peer selection received.\", data);\r\n    var peer = DataClient.peers.find((p) => { return p.id == data.id; });\r\n    if (!peer) return;\r\n    peer.range = data.range;\r\n    document.dispatchEvent(new CustomEvent('dataclient-cursor-update', {\r\n      detail: {\r\n        sender: DataClient,\r\n        source: peer\r\n      }\r\n    }));\r\n  }\r\n\r\n  // Server sent peer list\r\n  function onMsgPeers(data) {\r\n    var source = {};\r\n    var removedPeers = [];\r\n    var forceSendDetails = false;\r\n    var reportNewPeers = true;\r\n\r\n    if (!DataClient.me.id) forceSendDetails = true;\r\n    // Refresh local connection ID (we get it assigned from server)\r\n    DataClient.me.id = data.id;\r\n\r\n    if (forceSendDetails) {\r\n      DataClient.sendMyDetails();\r\n      return;\r\n    }\r\n\r\n    // Find removed peers\r\n    for (var i = 0; i < DataClient.peers.length; i++) {\r\n      var receivedPeer = data.peers.find((p) => { return p.id == DataClient.peers[i].id; });\r\n\r\n      if (!receivedPeer) {\r\n        removedPeers.push(DataClient.peers[i]);\r\n        console.log('[DataClient] Peer disconnected:', DataClient.peers[i]);\r\n\r\n        // If the source connection was removed set it\r\n        if (data.sourceId == DataClient.peers[i])\r\n          source = DataClient.peers[i];\r\n      } else if (receivedPeer.name && !DataClient.peers[i].name) {\r\n        console.log('[DataClient] User ' + receivedPeer.id + ' set username:', receivedPeer.name);\r\n        console.log('[DataClient] Peers after username update:', data.peers);\r\n      }\r\n    }\r\n\r\n    if (DataClient.peers.length == 0 && data.peers.length != 0) {\r\n      console.log('[DataClient] Initial list of peers received from server:', data.peers);\r\n      reportNewPeers = false;\r\n    }\r\n\r\n    for (var i = 0; i < data.peers.length; i++) {\r\n      // Set the source if it's still an active peers\r\n      if (data.sourceId == data.peers[i].id)\r\n        source = data.peers[i];\r\n\r\n      if (reportNewPeers && !DataClient.peers.find((p) => { return p.id == data.peers[i].id })) {\r\n        console.log('[DataClient] Peer connected:', data.peers[i]);\r\n        console.log('[DataClient] Peers after new user:', data.peers);\r\n      }\r\n    }\r\n\r\n    // Update peers array\r\n    DataClient.peers = data.peers;\r\n\r\n    // Tell consumer\r\n    document.dispatchEvent(new CustomEvent('dataclient-peers', {\r\n      detail: {\r\n        sender: DataClient,\r\n        source: source,\r\n        removedPeers: removedPeers\r\n      }\r\n    }));\r\n  }\r\n\r\n  function onMsgContent(data) {\r\n    console.log('[DataClient] Received document content.');\r\n    document.dispatchEvent(new CustomEvent('dataclient-content', {\r\n      detail: {\r\n        sender: DataClient,\r\n        data: data\r\n      }\r\n    }));\r\n  }\r\n\r\n  function onMsgDelta(data) {\r\n    console.log('[DataClient] Received document delta.');\r\n    document.dispatchEvent(new CustomEvent('dataclient-delta', {\r\n      detail: {\r\n        sender: DataClient,\r\n        data: data\r\n      }\r\n    }));\r\n  }\r\n\r\n  function initSocketHandlers() {\r\n\r\n    // Send initial message to register the client, and\r\n    // retrieve a list of current clients so we can set a colour.\r\n    DataClient.socket.onopen = function () {\r\n      DataClient.connected = true;\r\n      DataClient.sendMyDetails();\r\n      document.dispatchEvent(new CustomEvent('dataclient-connected', {\r\n        detail: {\r\n          sender: DataClient\r\n        }\r\n      }));\r\n    };\r\n\r\n    DataClient.socket.onmessage = function (message) {\r\n      var msgObj = JSON.parse(message.data);\r\n      if (msgObj.msg == \"peers\") onMsgPeers(msgObj.data);\r\n      else if (msgObj.msg == \"selection\") onMsgSelection(msgObj.data);\r\n      else if (msgObj.msg == \"content\") onMsgContent(msgObj.data);\r\n      else if (msgObj.msg == \"delta\") onMsgDelta(msgObj.data);\r\n    };\r\n\r\n    DataClient.socket.onclose = function (event) {\r\n      console.log('[DataClient] Socket closed. Event:', event);\r\n      DataClient.connected = false;\r\n      document.dispatchEvent(new CustomEvent('dataclient-disconnected', {\r\n        detail: {\r\n          sender: DataClient\r\n        }\r\n      }));\r\n    };\r\n\r\n    DataClient.socket.onerror = function (event) {\r\n      console.log('[DataClient] Error on socket. Event:', event);\r\n    };\r\n  }\r\n\r\n  return DataClient;\r\n}\r\n\r\n","\"use strict\";\r\n\r\nvar utils = require('./utils');\r\nvar dc1 = require('./data-client')();\r\ndc1.codeName = \"dc1\";\r\nvar dc2 = require('./data-client')();\r\ndc2.codeName = \"dc2\";\r\nvar q1, q2;     // Quill instances\r\nvar cm1, cm2;   // Cursors modules\r\n\r\nvar quillParams = {\r\n  theme: 'snow',\r\n  modules: {\r\n    cursors: {\r\n      autoRegisterListener: false\r\n    },\r\n    history: {\r\n      userOnly: true\r\n    }\r\n  },\r\n  readOnly: true\r\n};\r\n\r\n$(document).ready(function () {\r\n  Quill.register('modules/cursors', QuillCursors);\r\n  q1 = new Quill('#editorL', quillParams);\r\n  q2 = new Quill('#editorR', quillParams);\r\n  $(\".editorWrap\").removeClass(\"hidden\");\r\n  wireupConnectEvents([[dc1, $(\".half.left\")], [dc2, $(\".half.right\")]]);\r\n  wireupCursors();\r\n  wireupContent();\r\n});\r\n\r\nfunction wireupContent() {\r\n  q1.on('text-change', function (delta, oldDelta, source) {\r\n    //console.log(\"[shuang] q1 text-change\");\r\n    //console.log(\"[shuang] delta:\", delta);\r\n    //console.log(\"[shuang] source:\", source);\r\n    dc1.contentChanged(delta, oldDelta, source);\r\n  });\r\n  q2.on('text-change', function (delta, oldDelta, source) {\r\n    //console.log(\"[shuang] q2 text-change\");\r\n    //console.log(\"[shuang] delta:\", delta);\r\n    //console.log(\"[shuang] source:\", source);\r\n    dc2.contentChanged(delta, oldDelta, source);\r\n  });\r\n\r\n  document.addEventListener('dataclient-content', function (e) {\r\n    var q;\r\n    if (e.detail.sender.codeName == \"dc1\") q = q1;\r\n    else if (e.detail.sender.codeName == \"dc2\") q = q2;\r\n    q.setContents(e.detail.data);\r\n  });\r\n  document.addEventListener('dataclient-delta', function (e) {\r\n    var q;\r\n    if (e.detail.sender.codeName == \"dc1\") q = q1;\r\n    else if (e.detail.sender.codeName == \"dc2\") q = q2;\r\n    q.updateContents(e.detail.data);\r\n  });\r\n}\r\n\r\nfunction wireupCursors() {\r\n  cm1 = q1.getModule(\"cursors\");\r\n  cm1.registerTextChangeListener();\r\n  cm2 = q2.getModule(\"cursors\");\r\n  cm2.registerTextChangeListener();\r\n\r\n  //var debouncedSendCursorData = utils.debounce(function () {\r\n  //  var r1 = q1.getSelection();\r\n  //  if (r1) {\r\n  //    console.log('[shuang] Stopped typing, sending a cursor update/refresh.');\r\n  //    sendCursorData(r1);\r\n  //  }\r\n  //  var r2 = q2.getSelection();\r\n  //  if (r2) {\r\n  //    console.log('[shuang] Stopped typing, sending a cursor update/refresh.');\r\n  //    sendCursorData(r2);\r\n  //  }\r\n  //}, 1500);\r\n  //doc.on('nothing pending', debouncedSendCursorData);\r\n\r\n  q1.on('selection-change', function (range, oldRange, source) {\r\n    dc1.selectionChanged(range);\r\n  });\r\n\r\n  q2.on('selection-change', function (range, oldRange, source) {\r\n    dc2.selectionChanged(range);\r\n  });\r\n\r\n  document.addEventListener('dataclient-cursor-update', function (e) {\r\n    if (e.detail.sender.codeName == \"dc1\")\r\n      updateCursors(e.detail.source, cm1, dc1);\r\n    else if (e.detail.sender.codeName == \"dc2\")\r\n      updateCursors(e.detail.source, cm2, dc2);\r\n  });\r\n}\r\n\r\n\r\nfunction updateCursors(source, cm, dc) {\r\n  var activePeers = {};\r\n  // If cursors module has no cursors yet, time to show them all.\r\n  // Otherwise, only update sender's cursor.\r\n  var updateAll = Object.keys(cm.cursors).length == 0;\r\n\r\n  dc.peers.forEach((peer) => {\r\n    if (peer.id == dc.me.id) return;\r\n    // Update cursor that sent the update, or update all if we're initializing\r\n    if ((peer.id == source.id || updateAll) && peer.range) {\r\n      cm.setCursor(peer.id, peer.range, peer.name, peer.color);\r\n    }\r\n    // Seen, hence active\r\n    activePeers[peer.id] = peer;\r\n  });\r\n\r\n  // Clear cursors if peer is gone\r\n  Object.keys(cm.cursors).forEach((id) => {\r\n    if (!activePeers[id]) {\r\n      cm.removeCursor(id);\r\n    }\r\n  });\r\n}\r\n\r\n\r\nfunction wireupConnectEvents(clients) {\r\n  clients.forEach((x) => {\r\n    var dc = x[0];\r\n    var elm = x[1];\r\n    var elmButton = elm.find(\".connect input[type='button']\");\r\n    elmButton.click(function () {\r\n      if ($(this).hasClass(\"disabled\")) return;\r\n      if (dc.connected) dc.disconnect();\r\n      else {\r\n        var name = elm.find(\".connect input[type='text']\").val();\r\n        var color = dc.codeName == \"dc1\" ? \"red\" : \"blue\";\r\n        dc.connect(name, color);\r\n      }\r\n      $(this).addClass(\"disabled\");\r\n    });\r\n  });\r\n  document.addEventListener(\"dataclient-connected\", function (e, f) {\r\n    var elmBtn = null;\r\n    if (e.detail.sender.codeName == \"dc1\") {\r\n      elmBtn = $(\".half.left .connect input[type='button']\");\r\n      q1.enable();\r\n      updateCursors(dc1.me, cm1, dc1);\r\n    }\r\n    else {\r\n      elmBtn = $(\".half.right .connect input[type='button']\");\r\n      q2.enable();\r\n      updateCursors(dc2.me, cm2, dc2);\r\n    }\r\n    elmBtn.attr(\"value\", \"Disconnect\");\r\n    elmBtn.removeClass(\"disabled\");\r\n  });\r\n  document.addEventListener(\"dataclient-disconnected\", function (e) {\r\n    var elmBtn;\r\n    if (e.detail.sender.codeName == \"dc1\") {\r\n      elmBtn = $(\".half.left .connect input[type='button']\");\r\n      q1.disable();\r\n    }\r\n    else {\r\n      elmBtn = $(\".half.right .connect input[type='button']\");\r\n      q2.disable();\r\n    }\r\n    elmBtn.attr(\"value\", \"Connect\");\r\n    elmBtn.removeClass(\"disabled\");\r\n  });\r\n  document.addEventListener(\"dataclient-peers\", function (e) {\r\n    if (e.detail.sender.codeName == \"dc1\")\r\n      updateCursors(e.detail.source, cm1, dc1);\r\n    else if (e.detail.sender.codeName == \"dc2\")\r\n      updateCursors(e.detail.source, cm2, dc2);\r\n  });\r\n\r\n}\r\n\r\n","// Returns a function, that, as long as it continues to be invoked, will not\r\n// be triggered. The function will be called after it stops being called for\r\n// N milliseconds. If `immediate` is passed, trigger the function on the\r\n// leading edge, instead of the trailing.\r\nexports.debounce = function (func, wait, immediate) {\r\n  var timeout;\r\n  return function () {\r\n    var context = this,\r\n      args = arguments;\r\n    var later = function () {\r\n      timeout = null;\r\n      if (!immediate) func.apply(context, args);\r\n    };\r\n    var callNow = immediate && !timeout;\r\n    clearTimeout(timeout);\r\n    timeout = setTimeout(later, wait);\r\n    if (callNow) func.apply(context, args);\r\n  };\r\n};\r\n"]}